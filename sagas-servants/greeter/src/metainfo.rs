// This file is generated by rust-protobuf 2.5.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct MetaQuery {
    // message fields
    pub infoType: ::std::string::String,
    pub uri: ::std::string::String,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaQuery {
    fn default() -> &'a MetaQuery {
        <MetaQuery as ::protobuf::Message>::default_instance()
    }
}

impl MetaQuery {
    pub fn new() -> MetaQuery {
        ::std::default::Default::default()
    }

    // string infoType = 1;


    pub fn get_infoType(&self) -> &str {
        &self.infoType
    }
    pub fn clear_infoType(&mut self) {
        self.infoType.clear();
    }

    // Param is passed by value, moved
    pub fn set_infoType(&mut self, v: ::std::string::String) {
        self.infoType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_infoType(&mut self) -> &mut ::std::string::String {
        &mut self.infoType
    }

    // Take field
    pub fn take_infoType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.infoType, ::std::string::String::new())
    }

    // string uri = 2;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }

    // bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MetaQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.infoType)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.infoType.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.infoType);
        }
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.uri);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.infoType.is_empty() {
            os.write_string(1, &self.infoType)?;
        }
        if !self.uri.is_empty() {
            os.write_string(2, &self.uri)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaQuery {
        MetaQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "infoType",
                    |m: &MetaQuery| { &m.infoType },
                    |m: &mut MetaQuery| { &mut m.infoType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uri",
                    |m: &MetaQuery| { &m.uri },
                    |m: &mut MetaQuery| { &mut m.uri },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &MetaQuery| { &m.data },
                    |m: &mut MetaQuery| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaQuery>(
                    "MetaQuery",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaQuery {
        static mut instance: ::protobuf::lazy::Lazy<MetaQuery> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaQuery,
        };
        unsafe {
            instance.get(MetaQuery::new)
        }
    }
}

impl ::protobuf::Clear for MetaQuery {
    fn clear(&mut self) {
        self.infoType.clear();
        self.uri.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaPayload {
    // message fields
    pub field_type: MetaPayloadType,
    pub body: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaPayload {
    fn default() -> &'a MetaPayload {
        <MetaPayload as ::protobuf::Message>::default_instance()
    }
}

impl MetaPayload {
    pub fn new() -> MetaPayload {
        ::std::default::Default::default()
    }

    // .model.MetaPayloadType type = 1;


    pub fn get_field_type(&self) -> MetaPayloadType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = MetaPayloadType::ERROR_INFO;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: MetaPayloadType) {
        self.field_type = v;
    }

    // bytes body = 2;


    pub fn get_body(&self) -> &[u8] {
        &self.body
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.body
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.body, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MetaPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != MetaPayloadType::ERROR_INFO {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.body);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != MetaPayloadType::ERROR_INFO {
            os.write_enum(1, self.field_type.value())?;
        }
        if !self.body.is_empty() {
            os.write_bytes(2, &self.body)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaPayload {
        MetaPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MetaPayloadType>>(
                    "type",
                    |m: &MetaPayload| { &m.field_type },
                    |m: &mut MetaPayload| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "body",
                    |m: &MetaPayload| { &m.body },
                    |m: &mut MetaPayload| { &mut m.body },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaPayload>(
                    "MetaPayload",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaPayload {
        static mut instance: ::protobuf::lazy::Lazy<MetaPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaPayload,
        };
        unsafe {
            instance.get(MetaPayload::new)
        }
    }
}

impl ::protobuf::Clear for MetaPayload {
    fn clear(&mut self) {
        self.field_type = MetaPayloadType::ERROR_INFO;
        self.body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ErrorInfo {
    // message fields
    pub errorType: ErrorType,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ErrorInfo {
    fn default() -> &'a ErrorInfo {
        <ErrorInfo as ::protobuf::Message>::default_instance()
    }
}

impl ErrorInfo {
    pub fn new() -> ErrorInfo {
        ::std::default::Default::default()
    }

    // .model.ErrorType errorType = 1;


    pub fn get_errorType(&self) -> ErrorType {
        self.errorType
    }
    pub fn clear_errorType(&mut self) {
        self.errorType = ErrorType::SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_errorType(&mut self, v: ErrorType) {
        self.errorType = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ErrorInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.errorType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.errorType != ErrorType::SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.errorType);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.errorType != ErrorType::SUCCESS {
            os.write_enum(1, self.errorType.value())?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ErrorInfo {
        ErrorInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ErrorType>>(
                    "errorType",
                    |m: &ErrorInfo| { &m.errorType },
                    |m: &mut ErrorInfo| { &mut m.errorType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &ErrorInfo| { &m.message },
                    |m: &mut ErrorInfo| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ErrorInfo>(
                    "ErrorInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ErrorInfo {
        static mut instance: ::protobuf::lazy::Lazy<ErrorInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ErrorInfo,
        };
        unsafe {
            instance.get(ErrorInfo::new)
        }
    }
}

impl ::protobuf::Clear for ErrorInfo {
    fn clear(&mut self) {
        self.errorType = ErrorType::SUCCESS;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ErrorInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaField {
    // message fields
    pub name: ::std::string::String,
    pub field_type: ::std::string::String,
    pub pk: bool,
    pub notNull: bool,
    pub autoCreatedInternal: bool,
    pub enableAuditLog: bool,
    pub validators: ::protobuf::RepeatedField<::std::string::String>,
    pub encrypt: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaField {
    fn default() -> &'a MetaField {
        <MetaField as ::protobuf::Message>::default_instance()
    }
}

impl MetaField {
    pub fn new() -> MetaField {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string type = 2;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // bool pk = 3;


    pub fn get_pk(&self) -> bool {
        self.pk
    }
    pub fn clear_pk(&mut self) {
        self.pk = false;
    }

    // Param is passed by value, moved
    pub fn set_pk(&mut self, v: bool) {
        self.pk = v;
    }

    // bool notNull = 4;


    pub fn get_notNull(&self) -> bool {
        self.notNull
    }
    pub fn clear_notNull(&mut self) {
        self.notNull = false;
    }

    // Param is passed by value, moved
    pub fn set_notNull(&mut self, v: bool) {
        self.notNull = v;
    }

    // bool autoCreatedInternal = 5;


    pub fn get_autoCreatedInternal(&self) -> bool {
        self.autoCreatedInternal
    }
    pub fn clear_autoCreatedInternal(&mut self) {
        self.autoCreatedInternal = false;
    }

    // Param is passed by value, moved
    pub fn set_autoCreatedInternal(&mut self, v: bool) {
        self.autoCreatedInternal = v;
    }

    // bool enableAuditLog = 6;


    pub fn get_enableAuditLog(&self) -> bool {
        self.enableAuditLog
    }
    pub fn clear_enableAuditLog(&mut self) {
        self.enableAuditLog = false;
    }

    // Param is passed by value, moved
    pub fn set_enableAuditLog(&mut self, v: bool) {
        self.enableAuditLog = v;
    }

    // repeated string validators = 7;


    pub fn get_validators(&self) -> &[::std::string::String] {
        &self.validators
    }
    pub fn clear_validators(&mut self) {
        self.validators.clear();
    }

    // Param is passed by value, moved
    pub fn set_validators(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.validators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validators(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.validators
    }

    // Take field
    pub fn take_validators(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.validators, ::protobuf::RepeatedField::new())
    }

    // bool encrypt = 8;


    pub fn get_encrypt(&self) -> bool {
        self.encrypt
    }
    pub fn clear_encrypt(&mut self) {
        self.encrypt = false;
    }

    // Param is passed by value, moved
    pub fn set_encrypt(&mut self, v: bool) {
        self.encrypt = v;
    }
}

impl ::protobuf::Message for MetaField {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pk = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notNull = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autoCreatedInternal = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enableAuditLog = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.validators)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.encrypt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        if self.pk != false {
            my_size += 2;
        }
        if self.notNull != false {
            my_size += 2;
        }
        if self.autoCreatedInternal != false {
            my_size += 2;
        }
        if self.enableAuditLog != false {
            my_size += 2;
        }
        for value in &self.validators {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if self.encrypt != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        if self.pk != false {
            os.write_bool(3, self.pk)?;
        }
        if self.notNull != false {
            os.write_bool(4, self.notNull)?;
        }
        if self.autoCreatedInternal != false {
            os.write_bool(5, self.autoCreatedInternal)?;
        }
        if self.enableAuditLog != false {
            os.write_bool(6, self.enableAuditLog)?;
        }
        for v in &self.validators {
            os.write_string(7, &v)?;
        };
        if self.encrypt != false {
            os.write_bool(8, self.encrypt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaField {
        MetaField::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &MetaField| { &m.name },
                    |m: &mut MetaField| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &MetaField| { &m.field_type },
                    |m: &mut MetaField| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pk",
                    |m: &MetaField| { &m.pk },
                    |m: &mut MetaField| { &mut m.pk },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "notNull",
                    |m: &MetaField| { &m.notNull },
                    |m: &mut MetaField| { &mut m.notNull },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "autoCreatedInternal",
                    |m: &MetaField| { &m.autoCreatedInternal },
                    |m: &mut MetaField| { &mut m.autoCreatedInternal },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enableAuditLog",
                    |m: &MetaField| { &m.enableAuditLog },
                    |m: &mut MetaField| { &mut m.enableAuditLog },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "validators",
                    |m: &MetaField| { &m.validators },
                    |m: &mut MetaField| { &mut m.validators },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "encrypt",
                    |m: &MetaField| { &m.encrypt },
                    |m: &mut MetaField| { &mut m.encrypt },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaField>(
                    "MetaField",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaField {
        static mut instance: ::protobuf::lazy::Lazy<MetaField> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaField,
        };
        unsafe {
            instance.get(MetaField::new)
        }
    }
}

impl ::protobuf::Clear for MetaField {
    fn clear(&mut self) {
        self.name.clear();
        self.field_type.clear();
        self.pk = false;
        self.notNull = false;
        self.autoCreatedInternal = false;
        self.enableAuditLog = false;
        self.validators.clear();
        self.encrypt = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaField {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaKeyMap {
    // message fields
    pub fieldName: ::std::string::String,
    pub relFieldName: ::std::string::String,
    pub fullName: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaKeyMap {
    fn default() -> &'a MetaKeyMap {
        <MetaKeyMap as ::protobuf::Message>::default_instance()
    }
}

impl MetaKeyMap {
    pub fn new() -> MetaKeyMap {
        ::std::default::Default::default()
    }

    // string fieldName = 1;


    pub fn get_fieldName(&self) -> &str {
        &self.fieldName
    }
    pub fn clear_fieldName(&mut self) {
        self.fieldName.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldName(&mut self, v: ::std::string::String) {
        self.fieldName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldName(&mut self) -> &mut ::std::string::String {
        &mut self.fieldName
    }

    // Take field
    pub fn take_fieldName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fieldName, ::std::string::String::new())
    }

    // string relFieldName = 2;


    pub fn get_relFieldName(&self) -> &str {
        &self.relFieldName
    }
    pub fn clear_relFieldName(&mut self) {
        self.relFieldName.clear();
    }

    // Param is passed by value, moved
    pub fn set_relFieldName(&mut self, v: ::std::string::String) {
        self.relFieldName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relFieldName(&mut self) -> &mut ::std::string::String {
        &mut self.relFieldName
    }

    // Take field
    pub fn take_relFieldName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.relFieldName, ::std::string::String::new())
    }

    // string fullName = 3;


    pub fn get_fullName(&self) -> &str {
        &self.fullName
    }
    pub fn clear_fullName(&mut self) {
        self.fullName.clear();
    }

    // Param is passed by value, moved
    pub fn set_fullName(&mut self, v: ::std::string::String) {
        self.fullName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullName(&mut self) -> &mut ::std::string::String {
        &mut self.fullName
    }

    // Take field
    pub fn take_fullName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fullName, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MetaKeyMap {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fieldName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.relFieldName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fullName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.fieldName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.fieldName);
        }
        if !self.relFieldName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.relFieldName);
        }
        if !self.fullName.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.fullName);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.fieldName.is_empty() {
            os.write_string(1, &self.fieldName)?;
        }
        if !self.relFieldName.is_empty() {
            os.write_string(2, &self.relFieldName)?;
        }
        if !self.fullName.is_empty() {
            os.write_string(3, &self.fullName)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaKeyMap {
        MetaKeyMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fieldName",
                    |m: &MetaKeyMap| { &m.fieldName },
                    |m: &mut MetaKeyMap| { &mut m.fieldName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "relFieldName",
                    |m: &MetaKeyMap| { &m.relFieldName },
                    |m: &mut MetaKeyMap| { &mut m.relFieldName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fullName",
                    |m: &MetaKeyMap| { &m.fullName },
                    |m: &mut MetaKeyMap| { &mut m.fullName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaKeyMap>(
                    "MetaKeyMap",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaKeyMap {
        static mut instance: ::protobuf::lazy::Lazy<MetaKeyMap> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaKeyMap,
        };
        unsafe {
            instance.get(MetaKeyMap::new)
        }
    }
}

impl ::protobuf::Clear for MetaKeyMap {
    fn clear(&mut self) {
        self.fieldName.clear();
        self.relFieldName.clear();
        self.fullName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaKeyMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaKeyMap {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaRelation {
    // message fields
    pub title: ::std::string::String,
    pub field_type: ::std::string::String,
    pub relEntityName: ::std::string::String,
    pub fkName: ::std::string::String,
    pub keyMaps: ::protobuf::RepeatedField<MetaKeyMap>,
    pub autoRelation: bool,
    pub combinedName: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaRelation {
    fn default() -> &'a MetaRelation {
        <MetaRelation as ::protobuf::Message>::default_instance()
    }
}

impl MetaRelation {
    pub fn new() -> MetaRelation {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string type = 2;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string relEntityName = 3;


    pub fn get_relEntityName(&self) -> &str {
        &self.relEntityName
    }
    pub fn clear_relEntityName(&mut self) {
        self.relEntityName.clear();
    }

    // Param is passed by value, moved
    pub fn set_relEntityName(&mut self, v: ::std::string::String) {
        self.relEntityName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relEntityName(&mut self) -> &mut ::std::string::String {
        &mut self.relEntityName
    }

    // Take field
    pub fn take_relEntityName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.relEntityName, ::std::string::String::new())
    }

    // string fkName = 4;


    pub fn get_fkName(&self) -> &str {
        &self.fkName
    }
    pub fn clear_fkName(&mut self) {
        self.fkName.clear();
    }

    // Param is passed by value, moved
    pub fn set_fkName(&mut self, v: ::std::string::String) {
        self.fkName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fkName(&mut self) -> &mut ::std::string::String {
        &mut self.fkName
    }

    // Take field
    pub fn take_fkName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fkName, ::std::string::String::new())
    }

    // repeated .model.MetaKeyMap keyMaps = 5;


    pub fn get_keyMaps(&self) -> &[MetaKeyMap] {
        &self.keyMaps
    }
    pub fn clear_keyMaps(&mut self) {
        self.keyMaps.clear();
    }

    // Param is passed by value, moved
    pub fn set_keyMaps(&mut self, v: ::protobuf::RepeatedField<MetaKeyMap>) {
        self.keyMaps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keyMaps(&mut self) -> &mut ::protobuf::RepeatedField<MetaKeyMap> {
        &mut self.keyMaps
    }

    // Take field
    pub fn take_keyMaps(&mut self) -> ::protobuf::RepeatedField<MetaKeyMap> {
        ::std::mem::replace(&mut self.keyMaps, ::protobuf::RepeatedField::new())
    }

    // bool autoRelation = 6;


    pub fn get_autoRelation(&self) -> bool {
        self.autoRelation
    }
    pub fn clear_autoRelation(&mut self) {
        self.autoRelation = false;
    }

    // Param is passed by value, moved
    pub fn set_autoRelation(&mut self, v: bool) {
        self.autoRelation = v;
    }

    // string combinedName = 7;


    pub fn get_combinedName(&self) -> &str {
        &self.combinedName
    }
    pub fn clear_combinedName(&mut self) {
        self.combinedName.clear();
    }

    // Param is passed by value, moved
    pub fn set_combinedName(&mut self, v: ::std::string::String) {
        self.combinedName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_combinedName(&mut self) -> &mut ::std::string::String {
        &mut self.combinedName
    }

    // Take field
    pub fn take_combinedName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.combinedName, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MetaRelation {
    fn is_initialized(&self) -> bool {
        for v in &self.keyMaps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.relEntityName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fkName)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keyMaps)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autoRelation = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.combinedName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        if !self.relEntityName.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.relEntityName);
        }
        if !self.fkName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.fkName);
        }
        for value in &self.keyMaps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.autoRelation != false {
            my_size += 2;
        }
        if !self.combinedName.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.combinedName);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        if !self.relEntityName.is_empty() {
            os.write_string(3, &self.relEntityName)?;
        }
        if !self.fkName.is_empty() {
            os.write_string(4, &self.fkName)?;
        }
        for v in &self.keyMaps {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.autoRelation != false {
            os.write_bool(6, self.autoRelation)?;
        }
        if !self.combinedName.is_empty() {
            os.write_string(7, &self.combinedName)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaRelation {
        MetaRelation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &MetaRelation| { &m.title },
                    |m: &mut MetaRelation| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &MetaRelation| { &m.field_type },
                    |m: &mut MetaRelation| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "relEntityName",
                    |m: &MetaRelation| { &m.relEntityName },
                    |m: &mut MetaRelation| { &mut m.relEntityName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fkName",
                    |m: &MetaRelation| { &m.fkName },
                    |m: &mut MetaRelation| { &mut m.fkName },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaKeyMap>>(
                    "keyMaps",
                    |m: &MetaRelation| { &m.keyMaps },
                    |m: &mut MetaRelation| { &mut m.keyMaps },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "autoRelation",
                    |m: &MetaRelation| { &m.autoRelation },
                    |m: &mut MetaRelation| { &mut m.autoRelation },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "combinedName",
                    |m: &MetaRelation| { &m.combinedName },
                    |m: &mut MetaRelation| { &mut m.combinedName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaRelation>(
                    "MetaRelation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaRelation {
        static mut instance: ::protobuf::lazy::Lazy<MetaRelation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaRelation,
        };
        unsafe {
            instance.get(MetaRelation::new)
        }
    }
}

impl ::protobuf::Clear for MetaRelation {
    fn clear(&mut self) {
        self.title.clear();
        self.field_type.clear();
        self.relEntityName.clear();
        self.fkName.clear();
        self.keyMaps.clear();
        self.autoRelation = false;
        self.combinedName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaRelation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaRelation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaEntity {
    // message fields
    pub entityName: ::std::string::String,
    pub packageName: ::std::string::String,
    pub dependentOn: ::std::string::String,
    pub fields: ::protobuf::RepeatedField<MetaField>,
    pub relations: ::protobuf::RepeatedField<MetaRelation>,
    pub viewEntities: ::protobuf::RepeatedField<::std::string::String>,
    pub pks: ::protobuf::RepeatedField<::std::string::String>,
    pub nopks: ::protobuf::RepeatedField<::std::string::String>,
    pub version: ::std::string::String,
    pub description: ::std::string::String,
    pub title: ::std::string::String,
    pub defaultResourceName: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaEntity {
    fn default() -> &'a MetaEntity {
        <MetaEntity as ::protobuf::Message>::default_instance()
    }
}

impl MetaEntity {
    pub fn new() -> MetaEntity {
        ::std::default::Default::default()
    }

    // string entityName = 1;


    pub fn get_entityName(&self) -> &str {
        &self.entityName
    }
    pub fn clear_entityName(&mut self) {
        self.entityName.clear();
    }

    // Param is passed by value, moved
    pub fn set_entityName(&mut self, v: ::std::string::String) {
        self.entityName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entityName(&mut self) -> &mut ::std::string::String {
        &mut self.entityName
    }

    // Take field
    pub fn take_entityName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entityName, ::std::string::String::new())
    }

    // string packageName = 2;


    pub fn get_packageName(&self) -> &str {
        &self.packageName
    }
    pub fn clear_packageName(&mut self) {
        self.packageName.clear();
    }

    // Param is passed by value, moved
    pub fn set_packageName(&mut self, v: ::std::string::String) {
        self.packageName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packageName(&mut self) -> &mut ::std::string::String {
        &mut self.packageName
    }

    // Take field
    pub fn take_packageName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.packageName, ::std::string::String::new())
    }

    // string dependentOn = 3;


    pub fn get_dependentOn(&self) -> &str {
        &self.dependentOn
    }
    pub fn clear_dependentOn(&mut self) {
        self.dependentOn.clear();
    }

    // Param is passed by value, moved
    pub fn set_dependentOn(&mut self, v: ::std::string::String) {
        self.dependentOn = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dependentOn(&mut self) -> &mut ::std::string::String {
        &mut self.dependentOn
    }

    // Take field
    pub fn take_dependentOn(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dependentOn, ::std::string::String::new())
    }

    // repeated .model.MetaField fields = 4;


    pub fn get_fields(&self) -> &[MetaField] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<MetaField>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<MetaField> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<MetaField> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }

    // repeated .model.MetaRelation relations = 5;


    pub fn get_relations(&self) -> &[MetaRelation] {
        &self.relations
    }
    pub fn clear_relations(&mut self) {
        self.relations.clear();
    }

    // Param is passed by value, moved
    pub fn set_relations(&mut self, v: ::protobuf::RepeatedField<MetaRelation>) {
        self.relations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relations(&mut self) -> &mut ::protobuf::RepeatedField<MetaRelation> {
        &mut self.relations
    }

    // Take field
    pub fn take_relations(&mut self) -> ::protobuf::RepeatedField<MetaRelation> {
        ::std::mem::replace(&mut self.relations, ::protobuf::RepeatedField::new())
    }

    // repeated string viewEntities = 6;


    pub fn get_viewEntities(&self) -> &[::std::string::String] {
        &self.viewEntities
    }
    pub fn clear_viewEntities(&mut self) {
        self.viewEntities.clear();
    }

    // Param is passed by value, moved
    pub fn set_viewEntities(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.viewEntities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_viewEntities(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.viewEntities
    }

    // Take field
    pub fn take_viewEntities(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.viewEntities, ::protobuf::RepeatedField::new())
    }

    // repeated string pks = 7;


    pub fn get_pks(&self) -> &[::std::string::String] {
        &self.pks
    }
    pub fn clear_pks(&mut self) {
        self.pks.clear();
    }

    // Param is passed by value, moved
    pub fn set_pks(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.pks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pks(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.pks
    }

    // Take field
    pub fn take_pks(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.pks, ::protobuf::RepeatedField::new())
    }

    // repeated string nopks = 8;


    pub fn get_nopks(&self) -> &[::std::string::String] {
        &self.nopks
    }
    pub fn clear_nopks(&mut self) {
        self.nopks.clear();
    }

    // Param is passed by value, moved
    pub fn set_nopks(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.nopks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nopks(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.nopks
    }

    // Take field
    pub fn take_nopks(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.nopks, ::protobuf::RepeatedField::new())
    }

    // string version = 9;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string description = 10;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string title = 11;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string defaultResourceName = 12;


    pub fn get_defaultResourceName(&self) -> &str {
        &self.defaultResourceName
    }
    pub fn clear_defaultResourceName(&mut self) {
        self.defaultResourceName.clear();
    }

    // Param is passed by value, moved
    pub fn set_defaultResourceName(&mut self, v: ::std::string::String) {
        self.defaultResourceName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defaultResourceName(&mut self) -> &mut ::std::string::String {
        &mut self.defaultResourceName
    }

    // Take field
    pub fn take_defaultResourceName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.defaultResourceName, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MetaEntity {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entityName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.packageName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dependentOn)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relations)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.viewEntities)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.pks)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.nopks)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.defaultResourceName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entityName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entityName);
        }
        if !self.packageName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.packageName);
        }
        if !self.dependentOn.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.dependentOn);
        }
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.viewEntities {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.pks {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.nopks {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.version);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.description);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.title);
        }
        if !self.defaultResourceName.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.defaultResourceName);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.entityName.is_empty() {
            os.write_string(1, &self.entityName)?;
        }
        if !self.packageName.is_empty() {
            os.write_string(2, &self.packageName)?;
        }
        if !self.dependentOn.is_empty() {
            os.write_string(3, &self.dependentOn)?;
        }
        for v in &self.fields {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.relations {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.viewEntities {
            os.write_string(6, &v)?;
        };
        for v in &self.pks {
            os.write_string(7, &v)?;
        };
        for v in &self.nopks {
            os.write_string(8, &v)?;
        };
        if !self.version.is_empty() {
            os.write_string(9, &self.version)?;
        }
        if !self.description.is_empty() {
            os.write_string(10, &self.description)?;
        }
        if !self.title.is_empty() {
            os.write_string(11, &self.title)?;
        }
        if !self.defaultResourceName.is_empty() {
            os.write_string(12, &self.defaultResourceName)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaEntity {
        MetaEntity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "entityName",
                    |m: &MetaEntity| { &m.entityName },
                    |m: &mut MetaEntity| { &mut m.entityName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "packageName",
                    |m: &MetaEntity| { &m.packageName },
                    |m: &mut MetaEntity| { &mut m.packageName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dependentOn",
                    |m: &MetaEntity| { &m.dependentOn },
                    |m: &mut MetaEntity| { &mut m.dependentOn },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaField>>(
                    "fields",
                    |m: &MetaEntity| { &m.fields },
                    |m: &mut MetaEntity| { &mut m.fields },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaRelation>>(
                    "relations",
                    |m: &MetaEntity| { &m.relations },
                    |m: &mut MetaEntity| { &mut m.relations },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "viewEntities",
                    |m: &MetaEntity| { &m.viewEntities },
                    |m: &mut MetaEntity| { &mut m.viewEntities },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pks",
                    |m: &MetaEntity| { &m.pks },
                    |m: &mut MetaEntity| { &mut m.pks },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nopks",
                    |m: &MetaEntity| { &m.nopks },
                    |m: &mut MetaEntity| { &mut m.nopks },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &MetaEntity| { &m.version },
                    |m: &mut MetaEntity| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &MetaEntity| { &m.description },
                    |m: &mut MetaEntity| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &MetaEntity| { &m.title },
                    |m: &mut MetaEntity| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "defaultResourceName",
                    |m: &MetaEntity| { &m.defaultResourceName },
                    |m: &mut MetaEntity| { &mut m.defaultResourceName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaEntity>(
                    "MetaEntity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaEntity {
        static mut instance: ::protobuf::lazy::Lazy<MetaEntity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaEntity,
        };
        unsafe {
            instance.get(MetaEntity::new)
        }
    }
}

impl ::protobuf::Clear for MetaEntity {
    fn clear(&mut self) {
        self.entityName.clear();
        self.packageName.clear();
        self.dependentOn.clear();
        self.fields.clear();
        self.relations.clear();
        self.viewEntities.clear();
        self.pks.clear();
        self.nopks.clear();
        self.version.clear();
        self.description.clear();
        self.title.clear();
        self.defaultResourceName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaEntity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaEntity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaMemberEntity {
    // message fields
    pub entityAlias: ::std::string::String,
    pub entityName: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaMemberEntity {
    fn default() -> &'a MetaMemberEntity {
        <MetaMemberEntity as ::protobuf::Message>::default_instance()
    }
}

impl MetaMemberEntity {
    pub fn new() -> MetaMemberEntity {
        ::std::default::Default::default()
    }

    // string entityAlias = 1;


    pub fn get_entityAlias(&self) -> &str {
        &self.entityAlias
    }
    pub fn clear_entityAlias(&mut self) {
        self.entityAlias.clear();
    }

    // Param is passed by value, moved
    pub fn set_entityAlias(&mut self, v: ::std::string::String) {
        self.entityAlias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entityAlias(&mut self) -> &mut ::std::string::String {
        &mut self.entityAlias
    }

    // Take field
    pub fn take_entityAlias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entityAlias, ::std::string::String::new())
    }

    // string entityName = 2;


    pub fn get_entityName(&self) -> &str {
        &self.entityName
    }
    pub fn clear_entityName(&mut self) {
        self.entityName.clear();
    }

    // Param is passed by value, moved
    pub fn set_entityName(&mut self, v: ::std::string::String) {
        self.entityName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entityName(&mut self) -> &mut ::std::string::String {
        &mut self.entityName
    }

    // Take field
    pub fn take_entityName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entityName, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MetaMemberEntity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entityAlias)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entityName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entityAlias.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entityAlias);
        }
        if !self.entityName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entityName);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.entityAlias.is_empty() {
            os.write_string(1, &self.entityAlias)?;
        }
        if !self.entityName.is_empty() {
            os.write_string(2, &self.entityName)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaMemberEntity {
        MetaMemberEntity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "entityAlias",
                    |m: &MetaMemberEntity| { &m.entityAlias },
                    |m: &mut MetaMemberEntity| { &mut m.entityAlias },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "entityName",
                    |m: &MetaMemberEntity| { &m.entityName },
                    |m: &mut MetaMemberEntity| { &mut m.entityName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaMemberEntity>(
                    "MetaMemberEntity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaMemberEntity {
        static mut instance: ::protobuf::lazy::Lazy<MetaMemberEntity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaMemberEntity,
        };
        unsafe {
            instance.get(MetaMemberEntity::new)
        }
    }
}

impl ::protobuf::Clear for MetaMemberEntity {
    fn clear(&mut self) {
        self.entityAlias.clear();
        self.entityName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaMemberEntity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaMemberEntity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaAliasAll {
    // message fields
    pub entityAlias: ::std::string::String,
    pub prefix: ::std::string::String,
    pub fieldsToExclude: ::protobuf::RepeatedField<::std::string::String>,
    pub groupBy: bool,
    pub function: ::std::string::String,
    pub fieldSet: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaAliasAll {
    fn default() -> &'a MetaAliasAll {
        <MetaAliasAll as ::protobuf::Message>::default_instance()
    }
}

impl MetaAliasAll {
    pub fn new() -> MetaAliasAll {
        ::std::default::Default::default()
    }

    // string entityAlias = 1;


    pub fn get_entityAlias(&self) -> &str {
        &self.entityAlias
    }
    pub fn clear_entityAlias(&mut self) {
        self.entityAlias.clear();
    }

    // Param is passed by value, moved
    pub fn set_entityAlias(&mut self, v: ::std::string::String) {
        self.entityAlias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entityAlias(&mut self) -> &mut ::std::string::String {
        &mut self.entityAlias
    }

    // Take field
    pub fn take_entityAlias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entityAlias, ::std::string::String::new())
    }

    // string prefix = 2;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // repeated string fieldsToExclude = 3;


    pub fn get_fieldsToExclude(&self) -> &[::std::string::String] {
        &self.fieldsToExclude
    }
    pub fn clear_fieldsToExclude(&mut self) {
        self.fieldsToExclude.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldsToExclude(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.fieldsToExclude = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldsToExclude(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.fieldsToExclude
    }

    // Take field
    pub fn take_fieldsToExclude(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.fieldsToExclude, ::protobuf::RepeatedField::new())
    }

    // bool groupBy = 4;


    pub fn get_groupBy(&self) -> bool {
        self.groupBy
    }
    pub fn clear_groupBy(&mut self) {
        self.groupBy = false;
    }

    // Param is passed by value, moved
    pub fn set_groupBy(&mut self, v: bool) {
        self.groupBy = v;
    }

    // string function = 5;


    pub fn get_function(&self) -> &str {
        &self.function
    }
    pub fn clear_function(&mut self) {
        self.function.clear();
    }

    // Param is passed by value, moved
    pub fn set_function(&mut self, v: ::std::string::String) {
        self.function = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function(&mut self) -> &mut ::std::string::String {
        &mut self.function
    }

    // Take field
    pub fn take_function(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.function, ::std::string::String::new())
    }

    // string fieldSet = 6;


    pub fn get_fieldSet(&self) -> &str {
        &self.fieldSet
    }
    pub fn clear_fieldSet(&mut self) {
        self.fieldSet.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldSet(&mut self, v: ::std::string::String) {
        self.fieldSet = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldSet(&mut self) -> &mut ::std::string::String {
        &mut self.fieldSet
    }

    // Take field
    pub fn take_fieldSet(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fieldSet, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MetaAliasAll {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entityAlias)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.fieldsToExclude)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.groupBy = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.function)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fieldSet)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entityAlias.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entityAlias);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.prefix);
        }
        for value in &self.fieldsToExclude {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.groupBy != false {
            my_size += 2;
        }
        if !self.function.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.function);
        }
        if !self.fieldSet.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.fieldSet);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.entityAlias.is_empty() {
            os.write_string(1, &self.entityAlias)?;
        }
        if !self.prefix.is_empty() {
            os.write_string(2, &self.prefix)?;
        }
        for v in &self.fieldsToExclude {
            os.write_string(3, &v)?;
        };
        if self.groupBy != false {
            os.write_bool(4, self.groupBy)?;
        }
        if !self.function.is_empty() {
            os.write_string(5, &self.function)?;
        }
        if !self.fieldSet.is_empty() {
            os.write_string(6, &self.fieldSet)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaAliasAll {
        MetaAliasAll::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "entityAlias",
                    |m: &MetaAliasAll| { &m.entityAlias },
                    |m: &mut MetaAliasAll| { &mut m.entityAlias },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prefix",
                    |m: &MetaAliasAll| { &m.prefix },
                    |m: &mut MetaAliasAll| { &mut m.prefix },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fieldsToExclude",
                    |m: &MetaAliasAll| { &m.fieldsToExclude },
                    |m: &mut MetaAliasAll| { &mut m.fieldsToExclude },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "groupBy",
                    |m: &MetaAliasAll| { &m.groupBy },
                    |m: &mut MetaAliasAll| { &mut m.groupBy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "function",
                    |m: &MetaAliasAll| { &m.function },
                    |m: &mut MetaAliasAll| { &mut m.function },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fieldSet",
                    |m: &MetaAliasAll| { &m.fieldSet },
                    |m: &mut MetaAliasAll| { &mut m.fieldSet },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaAliasAll>(
                    "MetaAliasAll",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaAliasAll {
        static mut instance: ::protobuf::lazy::Lazy<MetaAliasAll> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaAliasAll,
        };
        unsafe {
            instance.get(MetaAliasAll::new)
        }
    }
}

impl ::protobuf::Clear for MetaAliasAll {
    fn clear(&mut self) {
        self.entityAlias.clear();
        self.prefix.clear();
        self.fieldsToExclude.clear();
        self.groupBy = false;
        self.function.clear();
        self.fieldSet.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaAliasAll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaAliasAll {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaAlias {
    // message fields
    pub entityAlias: ::std::string::String,
    pub name: ::std::string::String,
    pub field: ::std::string::String,
    pub colAlias: ::std::string::String,
    pub pk: bool,
    pub groupBy: bool,
    pub function: ::std::string::String,
    pub fieldSet: ::std::string::String,
    pub isFromAliasAll: bool,
    pub description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaAlias {
    fn default() -> &'a MetaAlias {
        <MetaAlias as ::protobuf::Message>::default_instance()
    }
}

impl MetaAlias {
    pub fn new() -> MetaAlias {
        ::std::default::Default::default()
    }

    // string entityAlias = 1;


    pub fn get_entityAlias(&self) -> &str {
        &self.entityAlias
    }
    pub fn clear_entityAlias(&mut self) {
        self.entityAlias.clear();
    }

    // Param is passed by value, moved
    pub fn set_entityAlias(&mut self, v: ::std::string::String) {
        self.entityAlias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entityAlias(&mut self) -> &mut ::std::string::String {
        &mut self.entityAlias
    }

    // Take field
    pub fn take_entityAlias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entityAlias, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string field = 3;


    pub fn get_field(&self) -> &str {
        &self.field
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field, ::std::string::String::new())
    }

    // string colAlias = 4;


    pub fn get_colAlias(&self) -> &str {
        &self.colAlias
    }
    pub fn clear_colAlias(&mut self) {
        self.colAlias.clear();
    }

    // Param is passed by value, moved
    pub fn set_colAlias(&mut self, v: ::std::string::String) {
        self.colAlias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_colAlias(&mut self) -> &mut ::std::string::String {
        &mut self.colAlias
    }

    // Take field
    pub fn take_colAlias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.colAlias, ::std::string::String::new())
    }

    // bool pk = 5;


    pub fn get_pk(&self) -> bool {
        self.pk
    }
    pub fn clear_pk(&mut self) {
        self.pk = false;
    }

    // Param is passed by value, moved
    pub fn set_pk(&mut self, v: bool) {
        self.pk = v;
    }

    // bool groupBy = 6;


    pub fn get_groupBy(&self) -> bool {
        self.groupBy
    }
    pub fn clear_groupBy(&mut self) {
        self.groupBy = false;
    }

    // Param is passed by value, moved
    pub fn set_groupBy(&mut self, v: bool) {
        self.groupBy = v;
    }

    // string function = 7;


    pub fn get_function(&self) -> &str {
        &self.function
    }
    pub fn clear_function(&mut self) {
        self.function.clear();
    }

    // Param is passed by value, moved
    pub fn set_function(&mut self, v: ::std::string::String) {
        self.function = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function(&mut self) -> &mut ::std::string::String {
        &mut self.function
    }

    // Take field
    pub fn take_function(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.function, ::std::string::String::new())
    }

    // string fieldSet = 8;


    pub fn get_fieldSet(&self) -> &str {
        &self.fieldSet
    }
    pub fn clear_fieldSet(&mut self) {
        self.fieldSet.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldSet(&mut self, v: ::std::string::String) {
        self.fieldSet = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldSet(&mut self) -> &mut ::std::string::String {
        &mut self.fieldSet
    }

    // Take field
    pub fn take_fieldSet(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fieldSet, ::std::string::String::new())
    }

    // bool isFromAliasAll = 9;


    pub fn get_isFromAliasAll(&self) -> bool {
        self.isFromAliasAll
    }
    pub fn clear_isFromAliasAll(&mut self) {
        self.isFromAliasAll = false;
    }

    // Param is passed by value, moved
    pub fn set_isFromAliasAll(&mut self, v: bool) {
        self.isFromAliasAll = v;
    }

    // string description = 10;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MetaAlias {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entityAlias)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.colAlias)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pk = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.groupBy = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.function)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fieldSet)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isFromAliasAll = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entityAlias.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entityAlias);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.field.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field);
        }
        if !self.colAlias.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.colAlias);
        }
        if self.pk != false {
            my_size += 2;
        }
        if self.groupBy != false {
            my_size += 2;
        }
        if !self.function.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.function);
        }
        if !self.fieldSet.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.fieldSet);
        }
        if self.isFromAliasAll != false {
            my_size += 2;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.entityAlias.is_empty() {
            os.write_string(1, &self.entityAlias)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.field.is_empty() {
            os.write_string(3, &self.field)?;
        }
        if !self.colAlias.is_empty() {
            os.write_string(4, &self.colAlias)?;
        }
        if self.pk != false {
            os.write_bool(5, self.pk)?;
        }
        if self.groupBy != false {
            os.write_bool(6, self.groupBy)?;
        }
        if !self.function.is_empty() {
            os.write_string(7, &self.function)?;
        }
        if !self.fieldSet.is_empty() {
            os.write_string(8, &self.fieldSet)?;
        }
        if self.isFromAliasAll != false {
            os.write_bool(9, self.isFromAliasAll)?;
        }
        if !self.description.is_empty() {
            os.write_string(10, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaAlias {
        MetaAlias::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "entityAlias",
                    |m: &MetaAlias| { &m.entityAlias },
                    |m: &mut MetaAlias| { &mut m.entityAlias },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &MetaAlias| { &m.name },
                    |m: &mut MetaAlias| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "field",
                    |m: &MetaAlias| { &m.field },
                    |m: &mut MetaAlias| { &mut m.field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "colAlias",
                    |m: &MetaAlias| { &m.colAlias },
                    |m: &mut MetaAlias| { &mut m.colAlias },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pk",
                    |m: &MetaAlias| { &m.pk },
                    |m: &mut MetaAlias| { &mut m.pk },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "groupBy",
                    |m: &MetaAlias| { &m.groupBy },
                    |m: &mut MetaAlias| { &mut m.groupBy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "function",
                    |m: &MetaAlias| { &m.function },
                    |m: &mut MetaAlias| { &mut m.function },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fieldSet",
                    |m: &MetaAlias| { &m.fieldSet },
                    |m: &mut MetaAlias| { &mut m.fieldSet },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isFromAliasAll",
                    |m: &MetaAlias| { &m.isFromAliasAll },
                    |m: &mut MetaAlias| { &mut m.isFromAliasAll },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &MetaAlias| { &m.description },
                    |m: &mut MetaAlias| { &mut m.description },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaAlias>(
                    "MetaAlias",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaAlias {
        static mut instance: ::protobuf::lazy::Lazy<MetaAlias> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaAlias,
        };
        unsafe {
            instance.get(MetaAlias::new)
        }
    }
}

impl ::protobuf::Clear for MetaAlias {
    fn clear(&mut self) {
        self.entityAlias.clear();
        self.name.clear();
        self.field.clear();
        self.colAlias.clear();
        self.pk = false;
        self.groupBy = false;
        self.function.clear();
        self.fieldSet.clear();
        self.isFromAliasAll = false;
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaAlias {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaAlias {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaViewEntityCondition {
    // message fields
    pub filterByDate: bool,
    pub distinct: bool,
    pub orderByList: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaViewEntityCondition {
    fn default() -> &'a MetaViewEntityCondition {
        <MetaViewEntityCondition as ::protobuf::Message>::default_instance()
    }
}

impl MetaViewEntityCondition {
    pub fn new() -> MetaViewEntityCondition {
        ::std::default::Default::default()
    }

    // bool filterByDate = 1;


    pub fn get_filterByDate(&self) -> bool {
        self.filterByDate
    }
    pub fn clear_filterByDate(&mut self) {
        self.filterByDate = false;
    }

    // Param is passed by value, moved
    pub fn set_filterByDate(&mut self, v: bool) {
        self.filterByDate = v;
    }

    // bool distinct = 2;


    pub fn get_distinct(&self) -> bool {
        self.distinct
    }
    pub fn clear_distinct(&mut self) {
        self.distinct = false;
    }

    // Param is passed by value, moved
    pub fn set_distinct(&mut self, v: bool) {
        self.distinct = v;
    }

    // repeated string orderByList = 3;


    pub fn get_orderByList(&self) -> &[::std::string::String] {
        &self.orderByList
    }
    pub fn clear_orderByList(&mut self) {
        self.orderByList.clear();
    }

    // Param is passed by value, moved
    pub fn set_orderByList(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.orderByList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orderByList(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.orderByList
    }

    // Take field
    pub fn take_orderByList(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.orderByList, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MetaViewEntityCondition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.filterByDate = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.distinct = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.orderByList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.filterByDate != false {
            my_size += 2;
        }
        if self.distinct != false {
            my_size += 2;
        }
        for value in &self.orderByList {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.filterByDate != false {
            os.write_bool(1, self.filterByDate)?;
        }
        if self.distinct != false {
            os.write_bool(2, self.distinct)?;
        }
        for v in &self.orderByList {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaViewEntityCondition {
        MetaViewEntityCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "filterByDate",
                    |m: &MetaViewEntityCondition| { &m.filterByDate },
                    |m: &mut MetaViewEntityCondition| { &mut m.filterByDate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "distinct",
                    |m: &MetaViewEntityCondition| { &m.distinct },
                    |m: &mut MetaViewEntityCondition| { &mut m.distinct },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "orderByList",
                    |m: &MetaViewEntityCondition| { &m.orderByList },
                    |m: &mut MetaViewEntityCondition| { &mut m.orderByList },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaViewEntityCondition>(
                    "MetaViewEntityCondition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaViewEntityCondition {
        static mut instance: ::protobuf::lazy::Lazy<MetaViewEntityCondition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaViewEntityCondition,
        };
        unsafe {
            instance.get(MetaViewEntityCondition::new)
        }
    }
}

impl ::protobuf::Clear for MetaViewEntityCondition {
    fn clear(&mut self) {
        self.filterByDate = false;
        self.distinct = false;
        self.orderByList.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaViewEntityCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaViewEntityCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaViewLink {
    // message fields
    pub entityAlias: ::std::string::String,
    pub relEntityAlias: ::std::string::String,
    pub relOptional: bool,
    pub keyMaps: ::protobuf::RepeatedField<MetaKeyMap>,
    pub viewEntityCondition: ::protobuf::SingularPtrField<MetaViewEntityCondition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaViewLink {
    fn default() -> &'a MetaViewLink {
        <MetaViewLink as ::protobuf::Message>::default_instance()
    }
}

impl MetaViewLink {
    pub fn new() -> MetaViewLink {
        ::std::default::Default::default()
    }

    // string entityAlias = 1;


    pub fn get_entityAlias(&self) -> &str {
        &self.entityAlias
    }
    pub fn clear_entityAlias(&mut self) {
        self.entityAlias.clear();
    }

    // Param is passed by value, moved
    pub fn set_entityAlias(&mut self, v: ::std::string::String) {
        self.entityAlias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entityAlias(&mut self) -> &mut ::std::string::String {
        &mut self.entityAlias
    }

    // Take field
    pub fn take_entityAlias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entityAlias, ::std::string::String::new())
    }

    // string relEntityAlias = 2;


    pub fn get_relEntityAlias(&self) -> &str {
        &self.relEntityAlias
    }
    pub fn clear_relEntityAlias(&mut self) {
        self.relEntityAlias.clear();
    }

    // Param is passed by value, moved
    pub fn set_relEntityAlias(&mut self, v: ::std::string::String) {
        self.relEntityAlias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relEntityAlias(&mut self) -> &mut ::std::string::String {
        &mut self.relEntityAlias
    }

    // Take field
    pub fn take_relEntityAlias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.relEntityAlias, ::std::string::String::new())
    }

    // bool relOptional = 3;


    pub fn get_relOptional(&self) -> bool {
        self.relOptional
    }
    pub fn clear_relOptional(&mut self) {
        self.relOptional = false;
    }

    // Param is passed by value, moved
    pub fn set_relOptional(&mut self, v: bool) {
        self.relOptional = v;
    }

    // repeated .model.MetaKeyMap keyMaps = 4;


    pub fn get_keyMaps(&self) -> &[MetaKeyMap] {
        &self.keyMaps
    }
    pub fn clear_keyMaps(&mut self) {
        self.keyMaps.clear();
    }

    // Param is passed by value, moved
    pub fn set_keyMaps(&mut self, v: ::protobuf::RepeatedField<MetaKeyMap>) {
        self.keyMaps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keyMaps(&mut self) -> &mut ::protobuf::RepeatedField<MetaKeyMap> {
        &mut self.keyMaps
    }

    // Take field
    pub fn take_keyMaps(&mut self) -> ::protobuf::RepeatedField<MetaKeyMap> {
        ::std::mem::replace(&mut self.keyMaps, ::protobuf::RepeatedField::new())
    }

    // .model.MetaViewEntityCondition viewEntityCondition = 5;


    pub fn get_viewEntityCondition(&self) -> &MetaViewEntityCondition {
        self.viewEntityCondition.as_ref().unwrap_or_else(|| MetaViewEntityCondition::default_instance())
    }
    pub fn clear_viewEntityCondition(&mut self) {
        self.viewEntityCondition.clear();
    }

    pub fn has_viewEntityCondition(&self) -> bool {
        self.viewEntityCondition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewEntityCondition(&mut self, v: MetaViewEntityCondition) {
        self.viewEntityCondition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_viewEntityCondition(&mut self) -> &mut MetaViewEntityCondition {
        if self.viewEntityCondition.is_none() {
            self.viewEntityCondition.set_default();
        }
        self.viewEntityCondition.as_mut().unwrap()
    }

    // Take field
    pub fn take_viewEntityCondition(&mut self) -> MetaViewEntityCondition {
        self.viewEntityCondition.take().unwrap_or_else(|| MetaViewEntityCondition::new())
    }
}

impl ::protobuf::Message for MetaViewLink {
    fn is_initialized(&self) -> bool {
        for v in &self.keyMaps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.viewEntityCondition {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entityAlias)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.relEntityAlias)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.relOptional = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keyMaps)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.viewEntityCondition)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entityAlias.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entityAlias);
        }
        if !self.relEntityAlias.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.relEntityAlias);
        }
        if self.relOptional != false {
            my_size += 2;
        }
        for value in &self.keyMaps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.viewEntityCondition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.entityAlias.is_empty() {
            os.write_string(1, &self.entityAlias)?;
        }
        if !self.relEntityAlias.is_empty() {
            os.write_string(2, &self.relEntityAlias)?;
        }
        if self.relOptional != false {
            os.write_bool(3, self.relOptional)?;
        }
        for v in &self.keyMaps {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.viewEntityCondition.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaViewLink {
        MetaViewLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "entityAlias",
                    |m: &MetaViewLink| { &m.entityAlias },
                    |m: &mut MetaViewLink| { &mut m.entityAlias },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "relEntityAlias",
                    |m: &MetaViewLink| { &m.relEntityAlias },
                    |m: &mut MetaViewLink| { &mut m.relEntityAlias },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "relOptional",
                    |m: &MetaViewLink| { &m.relOptional },
                    |m: &mut MetaViewLink| { &mut m.relOptional },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaKeyMap>>(
                    "keyMaps",
                    |m: &MetaViewLink| { &m.keyMaps },
                    |m: &mut MetaViewLink| { &mut m.keyMaps },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaViewEntityCondition>>(
                    "viewEntityCondition",
                    |m: &MetaViewLink| { &m.viewEntityCondition },
                    |m: &mut MetaViewLink| { &mut m.viewEntityCondition },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaViewLink>(
                    "MetaViewLink",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaViewLink {
        static mut instance: ::protobuf::lazy::Lazy<MetaViewLink> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaViewLink,
        };
        unsafe {
            instance.get(MetaViewLink::new)
        }
    }
}

impl ::protobuf::Clear for MetaViewLink {
    fn clear(&mut self) {
        self.entityAlias.clear();
        self.relEntityAlias.clear();
        self.relOptional = false;
        self.keyMaps.clear();
        self.viewEntityCondition.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaViewLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaViewLink {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaViewEntity {
    // message fields
    pub entityName: ::std::string::String,
    pub packageName: ::std::string::String,
    pub memberModelEntities: ::std::collections::HashMap<::std::string::String, MetaMemberEntity>,
    pub aliasAlls: ::protobuf::RepeatedField<MetaAliasAll>,
    pub aliases: ::protobuf::RepeatedField<MetaAlias>,
    pub viewLinks: ::protobuf::RepeatedField<MetaViewLink>,
    pub groupBys: ::protobuf::RepeatedField<MetaField>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaViewEntity {
    fn default() -> &'a MetaViewEntity {
        <MetaViewEntity as ::protobuf::Message>::default_instance()
    }
}

impl MetaViewEntity {
    pub fn new() -> MetaViewEntity {
        ::std::default::Default::default()
    }

    // string entityName = 1;


    pub fn get_entityName(&self) -> &str {
        &self.entityName
    }
    pub fn clear_entityName(&mut self) {
        self.entityName.clear();
    }

    // Param is passed by value, moved
    pub fn set_entityName(&mut self, v: ::std::string::String) {
        self.entityName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entityName(&mut self) -> &mut ::std::string::String {
        &mut self.entityName
    }

    // Take field
    pub fn take_entityName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entityName, ::std::string::String::new())
    }

    // string packageName = 2;


    pub fn get_packageName(&self) -> &str {
        &self.packageName
    }
    pub fn clear_packageName(&mut self) {
        self.packageName.clear();
    }

    // Param is passed by value, moved
    pub fn set_packageName(&mut self, v: ::std::string::String) {
        self.packageName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packageName(&mut self) -> &mut ::std::string::String {
        &mut self.packageName
    }

    // Take field
    pub fn take_packageName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.packageName, ::std::string::String::new())
    }

    // repeated .model.MetaViewEntity.MemberModelEntitiesEntry memberModelEntities = 3;


    pub fn get_memberModelEntities(&self) -> &::std::collections::HashMap<::std::string::String, MetaMemberEntity> {
        &self.memberModelEntities
    }
    pub fn clear_memberModelEntities(&mut self) {
        self.memberModelEntities.clear();
    }

    // Param is passed by value, moved
    pub fn set_memberModelEntities(&mut self, v: ::std::collections::HashMap<::std::string::String, MetaMemberEntity>) {
        self.memberModelEntities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memberModelEntities(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, MetaMemberEntity> {
        &mut self.memberModelEntities
    }

    // Take field
    pub fn take_memberModelEntities(&mut self) -> ::std::collections::HashMap<::std::string::String, MetaMemberEntity> {
        ::std::mem::replace(&mut self.memberModelEntities, ::std::collections::HashMap::new())
    }

    // repeated .model.MetaAliasAll aliasAlls = 4;


    pub fn get_aliasAlls(&self) -> &[MetaAliasAll] {
        &self.aliasAlls
    }
    pub fn clear_aliasAlls(&mut self) {
        self.aliasAlls.clear();
    }

    // Param is passed by value, moved
    pub fn set_aliasAlls(&mut self, v: ::protobuf::RepeatedField<MetaAliasAll>) {
        self.aliasAlls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_aliasAlls(&mut self) -> &mut ::protobuf::RepeatedField<MetaAliasAll> {
        &mut self.aliasAlls
    }

    // Take field
    pub fn take_aliasAlls(&mut self) -> ::protobuf::RepeatedField<MetaAliasAll> {
        ::std::mem::replace(&mut self.aliasAlls, ::protobuf::RepeatedField::new())
    }

    // repeated .model.MetaAlias aliases = 5;


    pub fn get_aliases(&self) -> &[MetaAlias] {
        &self.aliases
    }
    pub fn clear_aliases(&mut self) {
        self.aliases.clear();
    }

    // Param is passed by value, moved
    pub fn set_aliases(&mut self, v: ::protobuf::RepeatedField<MetaAlias>) {
        self.aliases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_aliases(&mut self) -> &mut ::protobuf::RepeatedField<MetaAlias> {
        &mut self.aliases
    }

    // Take field
    pub fn take_aliases(&mut self) -> ::protobuf::RepeatedField<MetaAlias> {
        ::std::mem::replace(&mut self.aliases, ::protobuf::RepeatedField::new())
    }

    // repeated .model.MetaViewLink viewLinks = 6;


    pub fn get_viewLinks(&self) -> &[MetaViewLink] {
        &self.viewLinks
    }
    pub fn clear_viewLinks(&mut self) {
        self.viewLinks.clear();
    }

    // Param is passed by value, moved
    pub fn set_viewLinks(&mut self, v: ::protobuf::RepeatedField<MetaViewLink>) {
        self.viewLinks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_viewLinks(&mut self) -> &mut ::protobuf::RepeatedField<MetaViewLink> {
        &mut self.viewLinks
    }

    // Take field
    pub fn take_viewLinks(&mut self) -> ::protobuf::RepeatedField<MetaViewLink> {
        ::std::mem::replace(&mut self.viewLinks, ::protobuf::RepeatedField::new())
    }

    // repeated .model.MetaField groupBys = 7;


    pub fn get_groupBys(&self) -> &[MetaField] {
        &self.groupBys
    }
    pub fn clear_groupBys(&mut self) {
        self.groupBys.clear();
    }

    // Param is passed by value, moved
    pub fn set_groupBys(&mut self, v: ::protobuf::RepeatedField<MetaField>) {
        self.groupBys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groupBys(&mut self) -> &mut ::protobuf::RepeatedField<MetaField> {
        &mut self.groupBys
    }

    // Take field
    pub fn take_groupBys(&mut self) -> ::protobuf::RepeatedField<MetaField> {
        ::std::mem::replace(&mut self.groupBys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MetaViewEntity {
    fn is_initialized(&self) -> bool {
        for v in &self.aliasAlls {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aliases {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.viewLinks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.groupBys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entityName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.packageName)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<MetaMemberEntity>>(wire_type, is, &mut self.memberModelEntities)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.aliasAlls)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.aliases)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.viewLinks)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.groupBys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entityName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entityName);
        }
        if !self.packageName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.packageName);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<MetaMemberEntity>>(3, &self.memberModelEntities);
        for value in &self.aliasAlls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.aliases {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.viewLinks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.groupBys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.entityName.is_empty() {
            os.write_string(1, &self.entityName)?;
        }
        if !self.packageName.is_empty() {
            os.write_string(2, &self.packageName)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<MetaMemberEntity>>(3, &self.memberModelEntities, os)?;
        for v in &self.aliasAlls {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.aliases {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.viewLinks {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.groupBys {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaViewEntity {
        MetaViewEntity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "entityName",
                    |m: &MetaViewEntity| { &m.entityName },
                    |m: &mut MetaViewEntity| { &mut m.entityName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "packageName",
                    |m: &MetaViewEntity| { &m.packageName },
                    |m: &mut MetaViewEntity| { &mut m.packageName },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<MetaMemberEntity>>(
                    "memberModelEntities",
                    |m: &MetaViewEntity| { &m.memberModelEntities },
                    |m: &mut MetaViewEntity| { &mut m.memberModelEntities },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaAliasAll>>(
                    "aliasAlls",
                    |m: &MetaViewEntity| { &m.aliasAlls },
                    |m: &mut MetaViewEntity| { &mut m.aliasAlls },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaAlias>>(
                    "aliases",
                    |m: &MetaViewEntity| { &m.aliases },
                    |m: &mut MetaViewEntity| { &mut m.aliases },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaViewLink>>(
                    "viewLinks",
                    |m: &MetaViewEntity| { &m.viewLinks },
                    |m: &mut MetaViewEntity| { &mut m.viewLinks },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaField>>(
                    "groupBys",
                    |m: &MetaViewEntity| { &m.groupBys },
                    |m: &mut MetaViewEntity| { &mut m.groupBys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaViewEntity>(
                    "MetaViewEntity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaViewEntity {
        static mut instance: ::protobuf::lazy::Lazy<MetaViewEntity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaViewEntity,
        };
        unsafe {
            instance.get(MetaViewEntity::new)
        }
    }
}

impl ::protobuf::Clear for MetaViewEntity {
    fn clear(&mut self) {
        self.entityName.clear();
        self.packageName.clear();
        self.memberModelEntities.clear();
        self.aliasAlls.clear();
        self.aliases.clear();
        self.viewLinks.clear();
        self.groupBys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaViewEntity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaViewEntity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaServiceIface {
    // message fields
    pub service: ::std::string::String,
    pub optional: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaServiceIface {
    fn default() -> &'a MetaServiceIface {
        <MetaServiceIface as ::protobuf::Message>::default_instance()
    }
}

impl MetaServiceIface {
    pub fn new() -> MetaServiceIface {
        ::std::default::Default::default()
    }

    // string service = 1;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // bool optional = 2;


    pub fn get_optional(&self) -> bool {
        self.optional
    }
    pub fn clear_optional(&mut self) {
        self.optional = false;
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = v;
    }
}

impl ::protobuf::Message for MetaServiceIface {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        if self.optional != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        if self.optional != false {
            os.write_bool(2, self.optional)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaServiceIface {
        MetaServiceIface::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service",
                    |m: &MetaServiceIface| { &m.service },
                    |m: &mut MetaServiceIface| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "optional",
                    |m: &MetaServiceIface| { &m.optional },
                    |m: &mut MetaServiceIface| { &mut m.optional },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaServiceIface>(
                    "MetaServiceIface",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaServiceIface {
        static mut instance: ::protobuf::lazy::Lazy<MetaServiceIface> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaServiceIface,
        };
        unsafe {
            instance.get(MetaServiceIface::new)
        }
    }
}

impl ::protobuf::Clear for MetaServiceIface {
    fn clear(&mut self) {
        self.service.clear();
        self.optional = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaServiceIface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaServiceIface {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaPermission {
    // message fields
    pub permissionType: i32,
    pub serviceModel: ::std::string::String,
    pub nameOrRole: ::std::string::String,
    pub action: ::std::string::String,
    pub permissionServiceName: ::std::string::String,
    pub permissionResourceDesc: ::std::string::String,
    pub auth: bool,
    pub clazz: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaPermission {
    fn default() -> &'a MetaPermission {
        <MetaPermission as ::protobuf::Message>::default_instance()
    }
}

impl MetaPermission {
    pub fn new() -> MetaPermission {
        ::std::default::Default::default()
    }

    // int32 permissionType = 1;


    pub fn get_permissionType(&self) -> i32 {
        self.permissionType
    }
    pub fn clear_permissionType(&mut self) {
        self.permissionType = 0;
    }

    // Param is passed by value, moved
    pub fn set_permissionType(&mut self, v: i32) {
        self.permissionType = v;
    }

    // string serviceModel = 2;


    pub fn get_serviceModel(&self) -> &str {
        &self.serviceModel
    }
    pub fn clear_serviceModel(&mut self) {
        self.serviceModel.clear();
    }

    // Param is passed by value, moved
    pub fn set_serviceModel(&mut self, v: ::std::string::String) {
        self.serviceModel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceModel(&mut self) -> &mut ::std::string::String {
        &mut self.serviceModel
    }

    // Take field
    pub fn take_serviceModel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serviceModel, ::std::string::String::new())
    }

    // string nameOrRole = 3;


    pub fn get_nameOrRole(&self) -> &str {
        &self.nameOrRole
    }
    pub fn clear_nameOrRole(&mut self) {
        self.nameOrRole.clear();
    }

    // Param is passed by value, moved
    pub fn set_nameOrRole(&mut self, v: ::std::string::String) {
        self.nameOrRole = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameOrRole(&mut self) -> &mut ::std::string::String {
        &mut self.nameOrRole
    }

    // Take field
    pub fn take_nameOrRole(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nameOrRole, ::std::string::String::new())
    }

    // string action = 4;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }

    // string permissionServiceName = 5;


    pub fn get_permissionServiceName(&self) -> &str {
        &self.permissionServiceName
    }
    pub fn clear_permissionServiceName(&mut self) {
        self.permissionServiceName.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissionServiceName(&mut self, v: ::std::string::String) {
        self.permissionServiceName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permissionServiceName(&mut self) -> &mut ::std::string::String {
        &mut self.permissionServiceName
    }

    // Take field
    pub fn take_permissionServiceName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.permissionServiceName, ::std::string::String::new())
    }

    // string permissionResourceDesc = 6;


    pub fn get_permissionResourceDesc(&self) -> &str {
        &self.permissionResourceDesc
    }
    pub fn clear_permissionResourceDesc(&mut self) {
        self.permissionResourceDesc.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissionResourceDesc(&mut self, v: ::std::string::String) {
        self.permissionResourceDesc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permissionResourceDesc(&mut self) -> &mut ::std::string::String {
        &mut self.permissionResourceDesc
    }

    // Take field
    pub fn take_permissionResourceDesc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.permissionResourceDesc, ::std::string::String::new())
    }

    // bool auth = 7;


    pub fn get_auth(&self) -> bool {
        self.auth
    }
    pub fn clear_auth(&mut self) {
        self.auth = false;
    }

    // Param is passed by value, moved
    pub fn set_auth(&mut self, v: bool) {
        self.auth = v;
    }

    // string clazz = 8;


    pub fn get_clazz(&self) -> &str {
        &self.clazz
    }
    pub fn clear_clazz(&mut self) {
        self.clazz.clear();
    }

    // Param is passed by value, moved
    pub fn set_clazz(&mut self, v: ::std::string::String) {
        self.clazz = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clazz(&mut self) -> &mut ::std::string::String {
        &mut self.clazz
    }

    // Take field
    pub fn take_clazz(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.clazz, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MetaPermission {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.permissionType = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serviceModel)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nameOrRole)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.permissionServiceName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.permissionResourceDesc)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.auth = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.clazz)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.permissionType != 0 {
            my_size += ::protobuf::rt::value_size(1, self.permissionType, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.serviceModel.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.serviceModel);
        }
        if !self.nameOrRole.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.nameOrRole);
        }
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        if !self.permissionServiceName.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.permissionServiceName);
        }
        if !self.permissionResourceDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.permissionResourceDesc);
        }
        if self.auth != false {
            my_size += 2;
        }
        if !self.clazz.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.clazz);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.permissionType != 0 {
            os.write_int32(1, self.permissionType)?;
        }
        if !self.serviceModel.is_empty() {
            os.write_string(2, &self.serviceModel)?;
        }
        if !self.nameOrRole.is_empty() {
            os.write_string(3, &self.nameOrRole)?;
        }
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        if !self.permissionServiceName.is_empty() {
            os.write_string(5, &self.permissionServiceName)?;
        }
        if !self.permissionResourceDesc.is_empty() {
            os.write_string(6, &self.permissionResourceDesc)?;
        }
        if self.auth != false {
            os.write_bool(7, self.auth)?;
        }
        if !self.clazz.is_empty() {
            os.write_string(8, &self.clazz)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaPermission {
        MetaPermission::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "permissionType",
                    |m: &MetaPermission| { &m.permissionType },
                    |m: &mut MetaPermission| { &mut m.permissionType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serviceModel",
                    |m: &MetaPermission| { &m.serviceModel },
                    |m: &mut MetaPermission| { &mut m.serviceModel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nameOrRole",
                    |m: &MetaPermission| { &m.nameOrRole },
                    |m: &mut MetaPermission| { &mut m.nameOrRole },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "action",
                    |m: &MetaPermission| { &m.action },
                    |m: &mut MetaPermission| { &mut m.action },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "permissionServiceName",
                    |m: &MetaPermission| { &m.permissionServiceName },
                    |m: &mut MetaPermission| { &mut m.permissionServiceName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "permissionResourceDesc",
                    |m: &MetaPermission| { &m.permissionResourceDesc },
                    |m: &mut MetaPermission| { &mut m.permissionResourceDesc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "auth",
                    |m: &MetaPermission| { &m.auth },
                    |m: &mut MetaPermission| { &mut m.auth },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clazz",
                    |m: &MetaPermission| { &m.clazz },
                    |m: &mut MetaPermission| { &mut m.clazz },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaPermission>(
                    "MetaPermission",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaPermission {
        static mut instance: ::protobuf::lazy::Lazy<MetaPermission> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaPermission,
        };
        unsafe {
            instance.get(MetaPermission::new)
        }
    }
}

impl ::protobuf::Clear for MetaPermission {
    fn clear(&mut self) {
        self.permissionType = 0;
        self.serviceModel.clear();
        self.nameOrRole.clear();
        self.action.clear();
        self.permissionServiceName.clear();
        self.permissionResourceDesc.clear();
        self.auth = false;
        self.clazz.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaPermission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaPermission {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaPermGroup {
    // message fields
    pub joinType: ::std::string::String,
    pub permissions: ::protobuf::RepeatedField<MetaPermission>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaPermGroup {
    fn default() -> &'a MetaPermGroup {
        <MetaPermGroup as ::protobuf::Message>::default_instance()
    }
}

impl MetaPermGroup {
    pub fn new() -> MetaPermGroup {
        ::std::default::Default::default()
    }

    // string joinType = 1;


    pub fn get_joinType(&self) -> &str {
        &self.joinType
    }
    pub fn clear_joinType(&mut self) {
        self.joinType.clear();
    }

    // Param is passed by value, moved
    pub fn set_joinType(&mut self, v: ::std::string::String) {
        self.joinType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_joinType(&mut self) -> &mut ::std::string::String {
        &mut self.joinType
    }

    // Take field
    pub fn take_joinType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.joinType, ::std::string::String::new())
    }

    // repeated .model.MetaPermission permissions = 2;


    pub fn get_permissions(&self) -> &[MetaPermission] {
        &self.permissions
    }
    pub fn clear_permissions(&mut self) {
        self.permissions.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: ::protobuf::RepeatedField<MetaPermission>) {
        self.permissions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_permissions(&mut self) -> &mut ::protobuf::RepeatedField<MetaPermission> {
        &mut self.permissions
    }

    // Take field
    pub fn take_permissions(&mut self) -> ::protobuf::RepeatedField<MetaPermission> {
        ::std::mem::replace(&mut self.permissions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MetaPermGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.permissions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.joinType)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.permissions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.joinType.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.joinType);
        }
        for value in &self.permissions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.joinType.is_empty() {
            os.write_string(1, &self.joinType)?;
        }
        for v in &self.permissions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaPermGroup {
        MetaPermGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "joinType",
                    |m: &MetaPermGroup| { &m.joinType },
                    |m: &mut MetaPermGroup| { &mut m.joinType },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaPermission>>(
                    "permissions",
                    |m: &MetaPermGroup| { &m.permissions },
                    |m: &mut MetaPermGroup| { &mut m.permissions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaPermGroup>(
                    "MetaPermGroup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaPermGroup {
        static mut instance: ::protobuf::lazy::Lazy<MetaPermGroup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaPermGroup,
        };
        unsafe {
            instance.get(MetaPermGroup::new)
        }
    }
}

impl ::protobuf::Clear for MetaPermGroup {
    fn clear(&mut self) {
        self.joinType.clear();
        self.permissions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaPermGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaPermGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaNotification {
    // message fields
    pub notificationGroupName: ::std::string::String,
    pub notificationEvent: ::std::string::String,
    pub notificationMode: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaNotification {
    fn default() -> &'a MetaNotification {
        <MetaNotification as ::protobuf::Message>::default_instance()
    }
}

impl MetaNotification {
    pub fn new() -> MetaNotification {
        ::std::default::Default::default()
    }

    // string notificationGroupName = 1;


    pub fn get_notificationGroupName(&self) -> &str {
        &self.notificationGroupName
    }
    pub fn clear_notificationGroupName(&mut self) {
        self.notificationGroupName.clear();
    }

    // Param is passed by value, moved
    pub fn set_notificationGroupName(&mut self, v: ::std::string::String) {
        self.notificationGroupName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notificationGroupName(&mut self) -> &mut ::std::string::String {
        &mut self.notificationGroupName
    }

    // Take field
    pub fn take_notificationGroupName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.notificationGroupName, ::std::string::String::new())
    }

    // string notificationEvent = 2;


    pub fn get_notificationEvent(&self) -> &str {
        &self.notificationEvent
    }
    pub fn clear_notificationEvent(&mut self) {
        self.notificationEvent.clear();
    }

    // Param is passed by value, moved
    pub fn set_notificationEvent(&mut self, v: ::std::string::String) {
        self.notificationEvent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notificationEvent(&mut self) -> &mut ::std::string::String {
        &mut self.notificationEvent
    }

    // Take field
    pub fn take_notificationEvent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.notificationEvent, ::std::string::String::new())
    }

    // string notificationMode = 3;


    pub fn get_notificationMode(&self) -> &str {
        &self.notificationMode
    }
    pub fn clear_notificationMode(&mut self) {
        self.notificationMode.clear();
    }

    // Param is passed by value, moved
    pub fn set_notificationMode(&mut self, v: ::std::string::String) {
        self.notificationMode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notificationMode(&mut self) -> &mut ::std::string::String {
        &mut self.notificationMode
    }

    // Take field
    pub fn take_notificationMode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.notificationMode, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MetaNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.notificationGroupName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.notificationEvent)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.notificationMode)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.notificationGroupName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.notificationGroupName);
        }
        if !self.notificationEvent.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.notificationEvent);
        }
        if !self.notificationMode.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.notificationMode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.notificationGroupName.is_empty() {
            os.write_string(1, &self.notificationGroupName)?;
        }
        if !self.notificationEvent.is_empty() {
            os.write_string(2, &self.notificationEvent)?;
        }
        if !self.notificationMode.is_empty() {
            os.write_string(3, &self.notificationMode)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaNotification {
        MetaNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "notificationGroupName",
                    |m: &MetaNotification| { &m.notificationGroupName },
                    |m: &mut MetaNotification| { &mut m.notificationGroupName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "notificationEvent",
                    |m: &MetaNotification| { &m.notificationEvent },
                    |m: &mut MetaNotification| { &mut m.notificationEvent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "notificationMode",
                    |m: &MetaNotification| { &m.notificationMode },
                    |m: &mut MetaNotification| { &mut m.notificationMode },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaNotification>(
                    "MetaNotification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaNotification {
        static mut instance: ::protobuf::lazy::Lazy<MetaNotification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaNotification,
        };
        unsafe {
            instance.get(MetaNotification::new)
        }
    }
}

impl ::protobuf::Clear for MetaNotification {
    fn clear(&mut self) {
        self.notificationGroupName.clear();
        self.notificationEvent.clear();
        self.notificationMode.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaParam {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub field_type: ::std::string::String,
    pub mode: ::std::string::String,
    pub formLabel: ::std::string::String,
    pub entityName: ::std::string::String,
    pub fieldName: ::std::string::String,
    pub defaultValue: ::std::string::String,
    pub optional: bool,
    pub overrideOptional: bool,
    pub formDisplay: bool,
    pub overrideFormDisplay: bool,
    pub allowHtml: ::std::string::String,
    pub internal: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaParam {
    fn default() -> &'a MetaParam {
        <MetaParam as ::protobuf::Message>::default_instance()
    }
}

impl MetaParam {
    pub fn new() -> MetaParam {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string type = 3;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string mode = 4;


    pub fn get_mode(&self) -> &str {
        &self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: ::std::string::String) {
        self.mode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode(&mut self) -> &mut ::std::string::String {
        &mut self.mode
    }

    // Take field
    pub fn take_mode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mode, ::std::string::String::new())
    }

    // string formLabel = 5;


    pub fn get_formLabel(&self) -> &str {
        &self.formLabel
    }
    pub fn clear_formLabel(&mut self) {
        self.formLabel.clear();
    }

    // Param is passed by value, moved
    pub fn set_formLabel(&mut self, v: ::std::string::String) {
        self.formLabel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_formLabel(&mut self) -> &mut ::std::string::String {
        &mut self.formLabel
    }

    // Take field
    pub fn take_formLabel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.formLabel, ::std::string::String::new())
    }

    // string entityName = 6;


    pub fn get_entityName(&self) -> &str {
        &self.entityName
    }
    pub fn clear_entityName(&mut self) {
        self.entityName.clear();
    }

    // Param is passed by value, moved
    pub fn set_entityName(&mut self, v: ::std::string::String) {
        self.entityName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entityName(&mut self) -> &mut ::std::string::String {
        &mut self.entityName
    }

    // Take field
    pub fn take_entityName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entityName, ::std::string::String::new())
    }

    // string fieldName = 7;


    pub fn get_fieldName(&self) -> &str {
        &self.fieldName
    }
    pub fn clear_fieldName(&mut self) {
        self.fieldName.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldName(&mut self, v: ::std::string::String) {
        self.fieldName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldName(&mut self) -> &mut ::std::string::String {
        &mut self.fieldName
    }

    // Take field
    pub fn take_fieldName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fieldName, ::std::string::String::new())
    }

    // string defaultValue = 9;


    pub fn get_defaultValue(&self) -> &str {
        &self.defaultValue
    }
    pub fn clear_defaultValue(&mut self) {
        self.defaultValue.clear();
    }

    // Param is passed by value, moved
    pub fn set_defaultValue(&mut self, v: ::std::string::String) {
        self.defaultValue = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defaultValue(&mut self) -> &mut ::std::string::String {
        &mut self.defaultValue
    }

    // Take field
    pub fn take_defaultValue(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.defaultValue, ::std::string::String::new())
    }

    // bool optional = 10;


    pub fn get_optional(&self) -> bool {
        self.optional
    }
    pub fn clear_optional(&mut self) {
        self.optional = false;
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = v;
    }

    // bool overrideOptional = 11;


    pub fn get_overrideOptional(&self) -> bool {
        self.overrideOptional
    }
    pub fn clear_overrideOptional(&mut self) {
        self.overrideOptional = false;
    }

    // Param is passed by value, moved
    pub fn set_overrideOptional(&mut self, v: bool) {
        self.overrideOptional = v;
    }

    // bool formDisplay = 12;


    pub fn get_formDisplay(&self) -> bool {
        self.formDisplay
    }
    pub fn clear_formDisplay(&mut self) {
        self.formDisplay = false;
    }

    // Param is passed by value, moved
    pub fn set_formDisplay(&mut self, v: bool) {
        self.formDisplay = v;
    }

    // bool overrideFormDisplay = 13;


    pub fn get_overrideFormDisplay(&self) -> bool {
        self.overrideFormDisplay
    }
    pub fn clear_overrideFormDisplay(&mut self) {
        self.overrideFormDisplay = false;
    }

    // Param is passed by value, moved
    pub fn set_overrideFormDisplay(&mut self, v: bool) {
        self.overrideFormDisplay = v;
    }

    // string allowHtml = 14;


    pub fn get_allowHtml(&self) -> &str {
        &self.allowHtml
    }
    pub fn clear_allowHtml(&mut self) {
        self.allowHtml.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowHtml(&mut self, v: ::std::string::String) {
        self.allowHtml = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allowHtml(&mut self) -> &mut ::std::string::String {
        &mut self.allowHtml
    }

    // Take field
    pub fn take_allowHtml(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.allowHtml, ::std::string::String::new())
    }

    // bool internal = 15;


    pub fn get_internal(&self) -> bool {
        self.internal
    }
    pub fn clear_internal(&mut self) {
        self.internal = false;
    }

    // Param is passed by value, moved
    pub fn set_internal(&mut self, v: bool) {
        self.internal = v;
    }
}

impl ::protobuf::Message for MetaParam {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mode)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.formLabel)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entityName)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fieldName)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.defaultValue)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.overrideOptional = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.formDisplay = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.overrideFormDisplay = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.allowHtml)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.internal = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field_type);
        }
        if !self.mode.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.mode);
        }
        if !self.formLabel.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.formLabel);
        }
        if !self.entityName.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.entityName);
        }
        if !self.fieldName.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.fieldName);
        }
        if !self.defaultValue.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.defaultValue);
        }
        if self.optional != false {
            my_size += 2;
        }
        if self.overrideOptional != false {
            my_size += 2;
        }
        if self.formDisplay != false {
            my_size += 2;
        }
        if self.overrideFormDisplay != false {
            my_size += 2;
        }
        if !self.allowHtml.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.allowHtml);
        }
        if self.internal != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(3, &self.field_type)?;
        }
        if !self.mode.is_empty() {
            os.write_string(4, &self.mode)?;
        }
        if !self.formLabel.is_empty() {
            os.write_string(5, &self.formLabel)?;
        }
        if !self.entityName.is_empty() {
            os.write_string(6, &self.entityName)?;
        }
        if !self.fieldName.is_empty() {
            os.write_string(7, &self.fieldName)?;
        }
        if !self.defaultValue.is_empty() {
            os.write_string(9, &self.defaultValue)?;
        }
        if self.optional != false {
            os.write_bool(10, self.optional)?;
        }
        if self.overrideOptional != false {
            os.write_bool(11, self.overrideOptional)?;
        }
        if self.formDisplay != false {
            os.write_bool(12, self.formDisplay)?;
        }
        if self.overrideFormDisplay != false {
            os.write_bool(13, self.overrideFormDisplay)?;
        }
        if !self.allowHtml.is_empty() {
            os.write_string(14, &self.allowHtml)?;
        }
        if self.internal != false {
            os.write_bool(15, self.internal)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaParam {
        MetaParam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &MetaParam| { &m.name },
                    |m: &mut MetaParam| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &MetaParam| { &m.description },
                    |m: &mut MetaParam| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &MetaParam| { &m.field_type },
                    |m: &mut MetaParam| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mode",
                    |m: &MetaParam| { &m.mode },
                    |m: &mut MetaParam| { &mut m.mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "formLabel",
                    |m: &MetaParam| { &m.formLabel },
                    |m: &mut MetaParam| { &mut m.formLabel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "entityName",
                    |m: &MetaParam| { &m.entityName },
                    |m: &mut MetaParam| { &mut m.entityName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fieldName",
                    |m: &MetaParam| { &m.fieldName },
                    |m: &mut MetaParam| { &mut m.fieldName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "defaultValue",
                    |m: &MetaParam| { &m.defaultValue },
                    |m: &mut MetaParam| { &mut m.defaultValue },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "optional",
                    |m: &MetaParam| { &m.optional },
                    |m: &mut MetaParam| { &mut m.optional },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "overrideOptional",
                    |m: &MetaParam| { &m.overrideOptional },
                    |m: &mut MetaParam| { &mut m.overrideOptional },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "formDisplay",
                    |m: &MetaParam| { &m.formDisplay },
                    |m: &mut MetaParam| { &mut m.formDisplay },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "overrideFormDisplay",
                    |m: &MetaParam| { &m.overrideFormDisplay },
                    |m: &mut MetaParam| { &mut m.overrideFormDisplay },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "allowHtml",
                    |m: &MetaParam| { &m.allowHtml },
                    |m: &mut MetaParam| { &mut m.allowHtml },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "internal",
                    |m: &MetaParam| { &m.internal },
                    |m: &mut MetaParam| { &mut m.internal },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaParam>(
                    "MetaParam",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaParam {
        static mut instance: ::protobuf::lazy::Lazy<MetaParam> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaParam,
        };
        unsafe {
            instance.get(MetaParam::new)
        }
    }
}

impl ::protobuf::Clear for MetaParam {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.field_type.clear();
        self.mode.clear();
        self.formLabel.clear();
        self.entityName.clear();
        self.fieldName.clear();
        self.defaultValue.clear();
        self.optional = false;
        self.overrideOptional = false;
        self.formDisplay = false;
        self.overrideFormDisplay = false;
        self.allowHtml.clear();
        self.internal = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaParam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaParam {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaService {
    // message fields
    pub name: ::std::string::String,
    pub definitionLocation: ::std::string::String,
    pub description: ::std::string::String,
    pub engineName: ::std::string::String,
    pub nameSpace: ::std::string::String,
    pub location: ::std::string::String,
    pub invoke: ::std::string::String,
    pub defaultEntityName: ::std::string::String,
    pub auth: bool,
    pub export: bool,
    pub debug: bool,
    pub validate: bool,
    pub permissionServiceName: ::std::string::String,
    pub permissionMainAction: ::std::string::String,
    pub permissionResourceDesc: ::std::string::String,
    pub implServices: ::protobuf::RepeatedField<MetaServiceIface>,
    pub overrideParameters: ::protobuf::RepeatedField<::std::string::String>,
    pub permissionGroups: ::protobuf::RepeatedField<MetaPermGroup>,
    pub notifications: ::protobuf::RepeatedField<MetaNotification>,
    pub parameters: ::protobuf::RepeatedField<MetaParam>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaService {
    fn default() -> &'a MetaService {
        <MetaService as ::protobuf::Message>::default_instance()
    }
}

impl MetaService {
    pub fn new() -> MetaService {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string definitionLocation = 2;


    pub fn get_definitionLocation(&self) -> &str {
        &self.definitionLocation
    }
    pub fn clear_definitionLocation(&mut self) {
        self.definitionLocation.clear();
    }

    // Param is passed by value, moved
    pub fn set_definitionLocation(&mut self, v: ::std::string::String) {
        self.definitionLocation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_definitionLocation(&mut self) -> &mut ::std::string::String {
        &mut self.definitionLocation
    }

    // Take field
    pub fn take_definitionLocation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.definitionLocation, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string engineName = 4;


    pub fn get_engineName(&self) -> &str {
        &self.engineName
    }
    pub fn clear_engineName(&mut self) {
        self.engineName.clear();
    }

    // Param is passed by value, moved
    pub fn set_engineName(&mut self, v: ::std::string::String) {
        self.engineName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_engineName(&mut self) -> &mut ::std::string::String {
        &mut self.engineName
    }

    // Take field
    pub fn take_engineName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.engineName, ::std::string::String::new())
    }

    // string nameSpace = 5;


    pub fn get_nameSpace(&self) -> &str {
        &self.nameSpace
    }
    pub fn clear_nameSpace(&mut self) {
        self.nameSpace.clear();
    }

    // Param is passed by value, moved
    pub fn set_nameSpace(&mut self, v: ::std::string::String) {
        self.nameSpace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nameSpace(&mut self) -> &mut ::std::string::String {
        &mut self.nameSpace
    }

    // Take field
    pub fn take_nameSpace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nameSpace, ::std::string::String::new())
    }

    // string location = 6;


    pub fn get_location(&self) -> &str {
        &self.location
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        &mut self.location
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location, ::std::string::String::new())
    }

    // string invoke = 7;


    pub fn get_invoke(&self) -> &str {
        &self.invoke
    }
    pub fn clear_invoke(&mut self) {
        self.invoke.clear();
    }

    // Param is passed by value, moved
    pub fn set_invoke(&mut self, v: ::std::string::String) {
        self.invoke = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invoke(&mut self) -> &mut ::std::string::String {
        &mut self.invoke
    }

    // Take field
    pub fn take_invoke(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.invoke, ::std::string::String::new())
    }

    // string defaultEntityName = 8;


    pub fn get_defaultEntityName(&self) -> &str {
        &self.defaultEntityName
    }
    pub fn clear_defaultEntityName(&mut self) {
        self.defaultEntityName.clear();
    }

    // Param is passed by value, moved
    pub fn set_defaultEntityName(&mut self, v: ::std::string::String) {
        self.defaultEntityName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defaultEntityName(&mut self) -> &mut ::std::string::String {
        &mut self.defaultEntityName
    }

    // Take field
    pub fn take_defaultEntityName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.defaultEntityName, ::std::string::String::new())
    }

    // bool auth = 9;


    pub fn get_auth(&self) -> bool {
        self.auth
    }
    pub fn clear_auth(&mut self) {
        self.auth = false;
    }

    // Param is passed by value, moved
    pub fn set_auth(&mut self, v: bool) {
        self.auth = v;
    }

    // bool export = 10;


    pub fn get_export(&self) -> bool {
        self.export
    }
    pub fn clear_export(&mut self) {
        self.export = false;
    }

    // Param is passed by value, moved
    pub fn set_export(&mut self, v: bool) {
        self.export = v;
    }

    // bool debug = 11;


    pub fn get_debug(&self) -> bool {
        self.debug
    }
    pub fn clear_debug(&mut self) {
        self.debug = false;
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: bool) {
        self.debug = v;
    }

    // bool validate = 12;


    pub fn get_validate(&self) -> bool {
        self.validate
    }
    pub fn clear_validate(&mut self) {
        self.validate = false;
    }

    // Param is passed by value, moved
    pub fn set_validate(&mut self, v: bool) {
        self.validate = v;
    }

    // string permissionServiceName = 13;


    pub fn get_permissionServiceName(&self) -> &str {
        &self.permissionServiceName
    }
    pub fn clear_permissionServiceName(&mut self) {
        self.permissionServiceName.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissionServiceName(&mut self, v: ::std::string::String) {
        self.permissionServiceName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permissionServiceName(&mut self) -> &mut ::std::string::String {
        &mut self.permissionServiceName
    }

    // Take field
    pub fn take_permissionServiceName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.permissionServiceName, ::std::string::String::new())
    }

    // string permissionMainAction = 14;


    pub fn get_permissionMainAction(&self) -> &str {
        &self.permissionMainAction
    }
    pub fn clear_permissionMainAction(&mut self) {
        self.permissionMainAction.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissionMainAction(&mut self, v: ::std::string::String) {
        self.permissionMainAction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permissionMainAction(&mut self) -> &mut ::std::string::String {
        &mut self.permissionMainAction
    }

    // Take field
    pub fn take_permissionMainAction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.permissionMainAction, ::std::string::String::new())
    }

    // string permissionResourceDesc = 15;


    pub fn get_permissionResourceDesc(&self) -> &str {
        &self.permissionResourceDesc
    }
    pub fn clear_permissionResourceDesc(&mut self) {
        self.permissionResourceDesc.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissionResourceDesc(&mut self, v: ::std::string::String) {
        self.permissionResourceDesc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permissionResourceDesc(&mut self) -> &mut ::std::string::String {
        &mut self.permissionResourceDesc
    }

    // Take field
    pub fn take_permissionResourceDesc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.permissionResourceDesc, ::std::string::String::new())
    }

    // repeated .model.MetaServiceIface implServices = 16;


    pub fn get_implServices(&self) -> &[MetaServiceIface] {
        &self.implServices
    }
    pub fn clear_implServices(&mut self) {
        self.implServices.clear();
    }

    // Param is passed by value, moved
    pub fn set_implServices(&mut self, v: ::protobuf::RepeatedField<MetaServiceIface>) {
        self.implServices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_implServices(&mut self) -> &mut ::protobuf::RepeatedField<MetaServiceIface> {
        &mut self.implServices
    }

    // Take field
    pub fn take_implServices(&mut self) -> ::protobuf::RepeatedField<MetaServiceIface> {
        ::std::mem::replace(&mut self.implServices, ::protobuf::RepeatedField::new())
    }

    // repeated string overrideParameters = 17;


    pub fn get_overrideParameters(&self) -> &[::std::string::String] {
        &self.overrideParameters
    }
    pub fn clear_overrideParameters(&mut self) {
        self.overrideParameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_overrideParameters(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.overrideParameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_overrideParameters(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.overrideParameters
    }

    // Take field
    pub fn take_overrideParameters(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.overrideParameters, ::protobuf::RepeatedField::new())
    }

    // repeated .model.MetaPermGroup permissionGroups = 18;


    pub fn get_permissionGroups(&self) -> &[MetaPermGroup] {
        &self.permissionGroups
    }
    pub fn clear_permissionGroups(&mut self) {
        self.permissionGroups.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissionGroups(&mut self, v: ::protobuf::RepeatedField<MetaPermGroup>) {
        self.permissionGroups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_permissionGroups(&mut self) -> &mut ::protobuf::RepeatedField<MetaPermGroup> {
        &mut self.permissionGroups
    }

    // Take field
    pub fn take_permissionGroups(&mut self) -> ::protobuf::RepeatedField<MetaPermGroup> {
        ::std::mem::replace(&mut self.permissionGroups, ::protobuf::RepeatedField::new())
    }

    // repeated .model.MetaNotification notifications = 19;


    pub fn get_notifications(&self) -> &[MetaNotification] {
        &self.notifications
    }
    pub fn clear_notifications(&mut self) {
        self.notifications.clear();
    }

    // Param is passed by value, moved
    pub fn set_notifications(&mut self, v: ::protobuf::RepeatedField<MetaNotification>) {
        self.notifications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notifications(&mut self) -> &mut ::protobuf::RepeatedField<MetaNotification> {
        &mut self.notifications
    }

    // Take field
    pub fn take_notifications(&mut self) -> ::protobuf::RepeatedField<MetaNotification> {
        ::std::mem::replace(&mut self.notifications, ::protobuf::RepeatedField::new())
    }

    // repeated .model.MetaParam parameters = 20;


    pub fn get_parameters(&self) -> &[MetaParam] {
        &self.parameters
    }
    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::protobuf::RepeatedField<MetaParam>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters(&mut self) -> &mut ::protobuf::RepeatedField<MetaParam> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::protobuf::RepeatedField<MetaParam> {
        ::std::mem::replace(&mut self.parameters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MetaService {
    fn is_initialized(&self) -> bool {
        for v in &self.implServices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.permissionGroups {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.notifications {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parameters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.definitionLocation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.engineName)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nameSpace)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.invoke)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.defaultEntityName)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.auth = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.export = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.debug = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.validate = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.permissionServiceName)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.permissionMainAction)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.permissionResourceDesc)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.implServices)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.overrideParameters)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.permissionGroups)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notifications)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parameters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.definitionLocation.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.definitionLocation);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if !self.engineName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.engineName);
        }
        if !self.nameSpace.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.nameSpace);
        }
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.location);
        }
        if !self.invoke.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.invoke);
        }
        if !self.defaultEntityName.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.defaultEntityName);
        }
        if self.auth != false {
            my_size += 2;
        }
        if self.export != false {
            my_size += 2;
        }
        if self.debug != false {
            my_size += 2;
        }
        if self.validate != false {
            my_size += 2;
        }
        if !self.permissionServiceName.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.permissionServiceName);
        }
        if !self.permissionMainAction.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.permissionMainAction);
        }
        if !self.permissionResourceDesc.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.permissionResourceDesc);
        }
        for value in &self.implServices {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.overrideParameters {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        for value in &self.permissionGroups {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.parameters {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.definitionLocation.is_empty() {
            os.write_string(2, &self.definitionLocation)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if !self.engineName.is_empty() {
            os.write_string(4, &self.engineName)?;
        }
        if !self.nameSpace.is_empty() {
            os.write_string(5, &self.nameSpace)?;
        }
        if !self.location.is_empty() {
            os.write_string(6, &self.location)?;
        }
        if !self.invoke.is_empty() {
            os.write_string(7, &self.invoke)?;
        }
        if !self.defaultEntityName.is_empty() {
            os.write_string(8, &self.defaultEntityName)?;
        }
        if self.auth != false {
            os.write_bool(9, self.auth)?;
        }
        if self.export != false {
            os.write_bool(10, self.export)?;
        }
        if self.debug != false {
            os.write_bool(11, self.debug)?;
        }
        if self.validate != false {
            os.write_bool(12, self.validate)?;
        }
        if !self.permissionServiceName.is_empty() {
            os.write_string(13, &self.permissionServiceName)?;
        }
        if !self.permissionMainAction.is_empty() {
            os.write_string(14, &self.permissionMainAction)?;
        }
        if !self.permissionResourceDesc.is_empty() {
            os.write_string(15, &self.permissionResourceDesc)?;
        }
        for v in &self.implServices {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.overrideParameters {
            os.write_string(17, &v)?;
        };
        for v in &self.permissionGroups {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.notifications {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.parameters {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaService {
        MetaService::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &MetaService| { &m.name },
                    |m: &mut MetaService| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "definitionLocation",
                    |m: &MetaService| { &m.definitionLocation },
                    |m: &mut MetaService| { &mut m.definitionLocation },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &MetaService| { &m.description },
                    |m: &mut MetaService| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "engineName",
                    |m: &MetaService| { &m.engineName },
                    |m: &mut MetaService| { &mut m.engineName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nameSpace",
                    |m: &MetaService| { &m.nameSpace },
                    |m: &mut MetaService| { &mut m.nameSpace },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "location",
                    |m: &MetaService| { &m.location },
                    |m: &mut MetaService| { &mut m.location },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "invoke",
                    |m: &MetaService| { &m.invoke },
                    |m: &mut MetaService| { &mut m.invoke },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "defaultEntityName",
                    |m: &MetaService| { &m.defaultEntityName },
                    |m: &mut MetaService| { &mut m.defaultEntityName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "auth",
                    |m: &MetaService| { &m.auth },
                    |m: &mut MetaService| { &mut m.auth },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "export",
                    |m: &MetaService| { &m.export },
                    |m: &mut MetaService| { &mut m.export },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "debug",
                    |m: &MetaService| { &m.debug },
                    |m: &mut MetaService| { &mut m.debug },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "validate",
                    |m: &MetaService| { &m.validate },
                    |m: &mut MetaService| { &mut m.validate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "permissionServiceName",
                    |m: &MetaService| { &m.permissionServiceName },
                    |m: &mut MetaService| { &mut m.permissionServiceName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "permissionMainAction",
                    |m: &MetaService| { &m.permissionMainAction },
                    |m: &mut MetaService| { &mut m.permissionMainAction },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "permissionResourceDesc",
                    |m: &MetaService| { &m.permissionResourceDesc },
                    |m: &mut MetaService| { &mut m.permissionResourceDesc },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaServiceIface>>(
                    "implServices",
                    |m: &MetaService| { &m.implServices },
                    |m: &mut MetaService| { &mut m.implServices },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "overrideParameters",
                    |m: &MetaService| { &m.overrideParameters },
                    |m: &mut MetaService| { &mut m.overrideParameters },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaPermGroup>>(
                    "permissionGroups",
                    |m: &MetaService| { &m.permissionGroups },
                    |m: &mut MetaService| { &mut m.permissionGroups },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaNotification>>(
                    "notifications",
                    |m: &MetaService| { &m.notifications },
                    |m: &mut MetaService| { &mut m.notifications },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaParam>>(
                    "parameters",
                    |m: &MetaService| { &m.parameters },
                    |m: &mut MetaService| { &mut m.parameters },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaService>(
                    "MetaService",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaService {
        static mut instance: ::protobuf::lazy::Lazy<MetaService> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaService,
        };
        unsafe {
            instance.get(MetaService::new)
        }
    }
}

impl ::protobuf::Clear for MetaService {
    fn clear(&mut self) {
        self.name.clear();
        self.definitionLocation.clear();
        self.description.clear();
        self.engineName.clear();
        self.nameSpace.clear();
        self.location.clear();
        self.invoke.clear();
        self.defaultEntityName.clear();
        self.auth = false;
        self.export = false;
        self.debug = false;
        self.validate = false;
        self.permissionServiceName.clear();
        self.permissionMainAction.clear();
        self.permissionResourceDesc.clear();
        self.implServices.clear();
        self.overrideParameters.clear();
        self.permissionGroups.clear();
        self.notifications.clear();
        self.parameters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaService {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceMetrics {
    // message fields
    pub name: ::std::string::String,
    pub serviceRate: f64,
    pub threshold: f64,
    pub totalEvents: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceMetrics {
    fn default() -> &'a ServiceMetrics {
        <ServiceMetrics as ::protobuf::Message>::default_instance()
    }
}

impl ServiceMetrics {
    pub fn new() -> ServiceMetrics {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // double serviceRate = 2;


    pub fn get_serviceRate(&self) -> f64 {
        self.serviceRate
    }
    pub fn clear_serviceRate(&mut self) {
        self.serviceRate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_serviceRate(&mut self, v: f64) {
        self.serviceRate = v;
    }

    // double threshold = 3;


    pub fn get_threshold(&self) -> f64 {
        self.threshold
    }
    pub fn clear_threshold(&mut self) {
        self.threshold = 0.;
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: f64) {
        self.threshold = v;
    }

    // int64 totalEvents = 4;


    pub fn get_totalEvents(&self) -> i64 {
        self.totalEvents
    }
    pub fn clear_totalEvents(&mut self) {
        self.totalEvents = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalEvents(&mut self, v: i64) {
        self.totalEvents = v;
    }
}

impl ::protobuf::Message for ServiceMetrics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.serviceRate = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.threshold = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalEvents = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.serviceRate != 0. {
            my_size += 9;
        }
        if self.threshold != 0. {
            my_size += 9;
        }
        if self.totalEvents != 0 {
            my_size += ::protobuf::rt::value_size(4, self.totalEvents, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.serviceRate != 0. {
            os.write_double(2, self.serviceRate)?;
        }
        if self.threshold != 0. {
            os.write_double(3, self.threshold)?;
        }
        if self.totalEvents != 0 {
            os.write_int64(4, self.totalEvents)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceMetrics {
        ServiceMetrics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ServiceMetrics| { &m.name },
                    |m: &mut ServiceMetrics| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "serviceRate",
                    |m: &ServiceMetrics| { &m.serviceRate },
                    |m: &mut ServiceMetrics| { &mut m.serviceRate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "threshold",
                    |m: &ServiceMetrics| { &m.threshold },
                    |m: &mut ServiceMetrics| { &mut m.threshold },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "totalEvents",
                    |m: &ServiceMetrics| { &m.totalEvents },
                    |m: &mut ServiceMetrics| { &mut m.totalEvents },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServiceMetrics>(
                    "ServiceMetrics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServiceMetrics {
        static mut instance: ::protobuf::lazy::Lazy<ServiceMetrics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServiceMetrics,
        };
        unsafe {
            instance.get(ServiceMetrics::new)
        }
    }
}

impl ::protobuf::Clear for ServiceMetrics {
    fn clear(&mut self) {
        self.name.clear();
        self.serviceRate = 0.;
        self.threshold = 0.;
        self.totalEvents = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceMetrics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MetaPayloadType {
    ERROR_INFO = 0,
    META_ENTITY = 1,
    META_SERVICE = 2,
    ENTITY_VALUE = 3,
    ENTITY_VALUE_LIST = 4,
    META_FORM = 5,
    META_FORM_DATA = 6,
    ACTION_RESULT = 7,
}

impl ::protobuf::ProtobufEnum for MetaPayloadType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MetaPayloadType> {
        match value {
            0 => ::std::option::Option::Some(MetaPayloadType::ERROR_INFO),
            1 => ::std::option::Option::Some(MetaPayloadType::META_ENTITY),
            2 => ::std::option::Option::Some(MetaPayloadType::META_SERVICE),
            3 => ::std::option::Option::Some(MetaPayloadType::ENTITY_VALUE),
            4 => ::std::option::Option::Some(MetaPayloadType::ENTITY_VALUE_LIST),
            5 => ::std::option::Option::Some(MetaPayloadType::META_FORM),
            6 => ::std::option::Option::Some(MetaPayloadType::META_FORM_DATA),
            7 => ::std::option::Option::Some(MetaPayloadType::ACTION_RESULT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MetaPayloadType] = &[
            MetaPayloadType::ERROR_INFO,
            MetaPayloadType::META_ENTITY,
            MetaPayloadType::META_SERVICE,
            MetaPayloadType::ENTITY_VALUE,
            MetaPayloadType::ENTITY_VALUE_LIST,
            MetaPayloadType::META_FORM,
            MetaPayloadType::META_FORM_DATA,
            MetaPayloadType::ACTION_RESULT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MetaPayloadType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MetaPayloadType {
}

impl ::std::default::Default for MetaPayloadType {
    fn default() -> Self {
        MetaPayloadType::ERROR_INFO
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaPayloadType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ErrorType {
    SUCCESS = 0,
    NOT_FOUND = 1,
    UNSUPPORT_META = 2,
    RETRIEVE_INFO_FAIL = 3,
}

impl ::protobuf::ProtobufEnum for ErrorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ErrorType> {
        match value {
            0 => ::std::option::Option::Some(ErrorType::SUCCESS),
            1 => ::std::option::Option::Some(ErrorType::NOT_FOUND),
            2 => ::std::option::Option::Some(ErrorType::UNSUPPORT_META),
            3 => ::std::option::Option::Some(ErrorType::RETRIEVE_INFO_FAIL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ErrorType] = &[
            ErrorType::SUCCESS,
            ErrorType::NOT_FOUND,
            ErrorType::UNSUPPORT_META,
            ErrorType::RETRIEVE_INFO_FAIL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ErrorType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ErrorType {
}

impl ::std::default::Default for ErrorType {
    fn default() -> Self {
        ErrorType::SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0emetainfo.proto\x12\x05model\"M\n\tMetaQuery\x12\x1a\n\x08infoType\
    \x18\x01\x20\x01(\tR\x08infoType\x12\x10\n\x03uri\x18\x02\x20\x01(\tR\
    \x03uri\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"M\n\x0bMetaPayl\
    oad\x12*\n\x04type\x18\x01\x20\x01(\x0e2\x16.model.MetaPayloadTypeR\x04t\
    ype\x12\x12\n\x04body\x18\x02\x20\x01(\x0cR\x04body\"U\n\tErrorInfo\x12.\
    \n\terrorType\x18\x01\x20\x01(\x0e2\x10.model.ErrorTypeR\terrorType\x12\
    \x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\xf1\x01\n\tMetaField\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04type\x18\x02\
    \x20\x01(\tR\x04type\x12\x0e\n\x02pk\x18\x03\x20\x01(\x08R\x02pk\x12\x18\
    \n\x07notNull\x18\x04\x20\x01(\x08R\x07notNull\x120\n\x13autoCreatedInte\
    rnal\x18\x05\x20\x01(\x08R\x13autoCreatedInternal\x12&\n\x0eenableAuditL\
    og\x18\x06\x20\x01(\x08R\x0eenableAuditLog\x12\x1e\n\nvalidators\x18\x07\
    \x20\x03(\tR\nvalidators\x12\x18\n\x07encrypt\x18\x08\x20\x01(\x08R\x07e\
    ncrypt\"j\n\nMetaKeyMap\x12\x1c\n\tfieldName\x18\x01\x20\x01(\tR\tfieldN\
    ame\x12\"\n\x0crelFieldName\x18\x02\x20\x01(\tR\x0crelFieldName\x12\x1a\
    \n\x08fullName\x18\x03\x20\x01(\tR\x08fullName\"\xeb\x01\n\x0cMetaRelati\
    on\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\x12\n\x04type\x18\
    \x02\x20\x01(\tR\x04type\x12$\n\rrelEntityName\x18\x03\x20\x01(\tR\rrelE\
    ntityName\x12\x16\n\x06fkName\x18\x04\x20\x01(\tR\x06fkName\x12+\n\x07ke\
    yMaps\x18\x05\x20\x03(\x0b2\x11.model.MetaKeyMapR\x07keyMaps\x12\"\n\x0c\
    autoRelation\x18\x06\x20\x01(\x08R\x0cautoRelation\x12\"\n\x0ccombinedNa\
    me\x18\x07\x20\x01(\tR\x0ccombinedName\"\x9d\x03\n\nMetaEntity\x12\x1e\n\
    \nentityName\x18\x01\x20\x01(\tR\nentityName\x12\x20\n\x0bpackageName\
    \x18\x02\x20\x01(\tR\x0bpackageName\x12\x20\n\x0bdependentOn\x18\x03\x20\
    \x01(\tR\x0bdependentOn\x12(\n\x06fields\x18\x04\x20\x03(\x0b2\x10.model\
    .MetaFieldR\x06fields\x121\n\trelations\x18\x05\x20\x03(\x0b2\x13.model.\
    MetaRelationR\trelations\x12\"\n\x0cviewEntities\x18\x06\x20\x03(\tR\x0c\
    viewEntities\x12\x10\n\x03pks\x18\x07\x20\x03(\tR\x03pks\x12\x14\n\x05no\
    pks\x18\x08\x20\x03(\tR\x05nopks\x12\x18\n\x07version\x18\t\x20\x01(\tR\
    \x07version\x12\x20\n\x0bdescription\x18\n\x20\x01(\tR\x0bdescription\
    \x12\x14\n\x05title\x18\x0b\x20\x01(\tR\x05title\x120\n\x13defaultResour\
    ceName\x18\x0c\x20\x01(\tR\x13defaultResourceName\"T\n\x10MetaMemberEnti\
    ty\x12\x20\n\x0bentityAlias\x18\x01\x20\x01(\tR\x0bentityAlias\x12\x1e\n\
    \nentityName\x18\x02\x20\x01(\tR\nentityName\"\xc4\x01\n\x0cMetaAliasAll\
    \x12\x20\n\x0bentityAlias\x18\x01\x20\x01(\tR\x0bentityAlias\x12\x16\n\
    \x06prefix\x18\x02\x20\x01(\tR\x06prefix\x12(\n\x0ffieldsToExclude\x18\
    \x03\x20\x03(\tR\x0ffieldsToExclude\x12\x18\n\x07groupBy\x18\x04\x20\x01\
    (\x08R\x07groupBy\x12\x1a\n\x08function\x18\x05\x20\x01(\tR\x08function\
    \x12\x1a\n\x08fieldSet\x18\x06\x20\x01(\tR\x08fieldSet\"\x9f\x02\n\tMeta\
    Alias\x12\x20\n\x0bentityAlias\x18\x01\x20\x01(\tR\x0bentityAlias\x12\
    \x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x14\n\x05field\x18\x03\
    \x20\x01(\tR\x05field\x12\x1a\n\x08colAlias\x18\x04\x20\x01(\tR\x08colAl\
    ias\x12\x0e\n\x02pk\x18\x05\x20\x01(\x08R\x02pk\x12\x18\n\x07groupBy\x18\
    \x06\x20\x01(\x08R\x07groupBy\x12\x1a\n\x08function\x18\x07\x20\x01(\tR\
    \x08function\x12\x1a\n\x08fieldSet\x18\x08\x20\x01(\tR\x08fieldSet\x12&\
    \n\x0eisFromAliasAll\x18\t\x20\x01(\x08R\x0eisFromAliasAll\x12\x20\n\x0b\
    description\x18\n\x20\x01(\tR\x0bdescription\"{\n\x17MetaViewEntityCondi\
    tion\x12\"\n\x0cfilterByDate\x18\x01\x20\x01(\x08R\x0cfilterByDate\x12\
    \x1a\n\x08distinct\x18\x02\x20\x01(\x08R\x08distinct\x12\x20\n\x0borderB\
    yList\x18\x03\x20\x03(\tR\x0borderByList\"\xf9\x01\n\x0cMetaViewLink\x12\
    \x20\n\x0bentityAlias\x18\x01\x20\x01(\tR\x0bentityAlias\x12&\n\x0erelEn\
    tityAlias\x18\x02\x20\x01(\tR\x0erelEntityAlias\x12\x20\n\x0brelOptional\
    \x18\x03\x20\x01(\x08R\x0brelOptional\x12+\n\x07keyMaps\x18\x04\x20\x03(\
    \x0b2\x11.model.MetaKeyMapR\x07keyMaps\x12P\n\x13viewEntityCondition\x18\
    \x05\x20\x01(\x0b2\x1e.model.MetaViewEntityConditionR\x13viewEntityCondi\
    tion\"\xd5\x03\n\x0eMetaViewEntity\x12\x1e\n\nentityName\x18\x01\x20\x01\
    (\tR\nentityName\x12\x20\n\x0bpackageName\x18\x02\x20\x01(\tR\x0bpackage\
    Name\x12`\n\x13memberModelEntities\x18\x03\x20\x03(\x0b2..model.MetaView\
    Entity.MemberModelEntitiesEntryR\x13memberModelEntities\x121\n\taliasAll\
    s\x18\x04\x20\x03(\x0b2\x13.model.MetaAliasAllR\taliasAlls\x12*\n\x07ali\
    ases\x18\x05\x20\x03(\x0b2\x10.model.MetaAliasR\x07aliases\x121\n\tviewL\
    inks\x18\x06\x20\x03(\x0b2\x13.model.MetaViewLinkR\tviewLinks\x12,\n\x08\
    groupBys\x18\x07\x20\x03(\x0b2\x10.model.MetaFieldR\x08groupBys\x1a_\n\
    \x18MemberModelEntitiesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12-\n\x05value\x18\x02\x20\x01(\x0b2\x17.model.MetaMemberEntityR\x05va\
    lue:\x028\x01\"H\n\x10MetaServiceIface\x12\x18\n\x07service\x18\x01\x20\
    \x01(\tR\x07service\x12\x1a\n\x08optional\x18\x02\x20\x01(\x08R\x08optio\
    nal\"\xac\x02\n\x0eMetaPermission\x12&\n\x0epermissionType\x18\x01\x20\
    \x01(\x05R\x0epermissionType\x12\"\n\x0cserviceModel\x18\x02\x20\x01(\tR\
    \x0cserviceModel\x12\x1e\n\nnameOrRole\x18\x03\x20\x01(\tR\nnameOrRole\
    \x12\x16\n\x06action\x18\x04\x20\x01(\tR\x06action\x124\n\x15permissionS\
    erviceName\x18\x05\x20\x01(\tR\x15permissionServiceName\x126\n\x16permis\
    sionResourceDesc\x18\x06\x20\x01(\tR\x16permissionResourceDesc\x12\x12\n\
    \x04auth\x18\x07\x20\x01(\x08R\x04auth\x12\x14\n\x05clazz\x18\x08\x20\
    \x01(\tR\x05clazz\"d\n\rMetaPermGroup\x12\x1a\n\x08joinType\x18\x01\x20\
    \x01(\tR\x08joinType\x127\n\x0bpermissions\x18\x02\x20\x03(\x0b2\x15.mod\
    el.MetaPermissionR\x0bpermissions\"\xa2\x01\n\x10MetaNotification\x124\n\
    \x15notificationGroupName\x18\x01\x20\x01(\tR\x15notificationGroupName\
    \x12,\n\x11notificationEvent\x18\x02\x20\x01(\tR\x11notificationEvent\
    \x12*\n\x10notificationMode\x18\x03\x20\x01(\tR\x10notificationMode\"\
    \xbf\x03\n\tMetaParam\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12\x12\n\x04ty\
    pe\x18\x03\x20\x01(\tR\x04type\x12\x12\n\x04mode\x18\x04\x20\x01(\tR\x04\
    mode\x12\x1c\n\tformLabel\x18\x05\x20\x01(\tR\tformLabel\x12\x1e\n\nenti\
    tyName\x18\x06\x20\x01(\tR\nentityName\x12\x1c\n\tfieldName\x18\x07\x20\
    \x01(\tR\tfieldName\x12\"\n\x0cdefaultValue\x18\t\x20\x01(\tR\x0cdefault\
    Value\x12\x1a\n\x08optional\x18\n\x20\x01(\x08R\x08optional\x12*\n\x10ov\
    errideOptional\x18\x0b\x20\x01(\x08R\x10overrideOptional\x12\x20\n\x0bfo\
    rmDisplay\x18\x0c\x20\x01(\x08R\x0bformDisplay\x120\n\x13overrideFormDis\
    play\x18\r\x20\x01(\x08R\x13overrideFormDisplay\x12\x1c\n\tallowHtml\x18\
    \x0e\x20\x01(\tR\tallowHtml\x12\x1a\n\x08internal\x18\x0f\x20\x01(\x08R\
    \x08internal\"\xb3\x06\n\x0bMetaService\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12.\n\x12definitionLocation\x18\x02\x20\x01(\tR\x12def\
    initionLocation\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescript\
    ion\x12\x1e\n\nengineName\x18\x04\x20\x01(\tR\nengineName\x12\x1c\n\tnam\
    eSpace\x18\x05\x20\x01(\tR\tnameSpace\x12\x1a\n\x08location\x18\x06\x20\
    \x01(\tR\x08location\x12\x16\n\x06invoke\x18\x07\x20\x01(\tR\x06invoke\
    \x12,\n\x11defaultEntityName\x18\x08\x20\x01(\tR\x11defaultEntityName\
    \x12\x12\n\x04auth\x18\t\x20\x01(\x08R\x04auth\x12\x16\n\x06export\x18\n\
    \x20\x01(\x08R\x06export\x12\x14\n\x05debug\x18\x0b\x20\x01(\x08R\x05deb\
    ug\x12\x1a\n\x08validate\x18\x0c\x20\x01(\x08R\x08validate\x124\n\x15per\
    missionServiceName\x18\r\x20\x01(\tR\x15permissionServiceName\x122\n\x14\
    permissionMainAction\x18\x0e\x20\x01(\tR\x14permissionMainAction\x126\n\
    \x16permissionResourceDesc\x18\x0f\x20\x01(\tR\x16permissionResourceDesc\
    \x12;\n\x0cimplServices\x18\x10\x20\x03(\x0b2\x17.model.MetaServiceIface\
    R\x0cimplServices\x12.\n\x12overrideParameters\x18\x11\x20\x03(\tR\x12ov\
    errideParameters\x12@\n\x10permissionGroups\x18\x12\x20\x03(\x0b2\x14.mo\
    del.MetaPermGroupR\x10permissionGroups\x12=\n\rnotifications\x18\x13\x20\
    \x03(\x0b2\x17.model.MetaNotificationR\rnotifications\x120\n\nparameters\
    \x18\x14\x20\x03(\x0b2\x10.model.MetaParamR\nparameters\"\x86\x01\n\x0eS\
    erviceMetrics\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x20\n\
    \x0bserviceRate\x18\x02\x20\x01(\x01R\x0bserviceRate\x12\x1c\n\tthreshol\
    d\x18\x03\x20\x01(\x01R\tthreshold\x12\x20\n\x0btotalEvents\x18\x04\x20\
    \x01(\x03R\x0btotalEvents*\xa3\x01\n\x0fMetaPayloadType\x12\x0e\n\nERROR\
    _INFO\x10\0\x12\x0f\n\x0bMETA_ENTITY\x10\x01\x12\x10\n\x0cMETA_SERVICE\
    \x10\x02\x12\x10\n\x0cENTITY_VALUE\x10\x03\x12\x15\n\x11ENTITY_VALUE_LIS\
    T\x10\x04\x12\r\n\tMETA_FORM\x10\x05\x12\x12\n\x0eMETA_FORM_DATA\x10\x06\
    \x12\x11\n\rACTION_RESULT\x10\x07*S\n\tErrorType\x12\x0b\n\x07SUCCESS\
    \x10\0\x12\r\n\tNOT_FOUND\x10\x01\x12\x12\n\x0eUNSUPPORT_META\x10\x02\
    \x12\x16\n\x12RETRIEVE_INFO_FAIL\x10\x03B\x18\n\x14com.sagas.meta.modelP\
    \x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
