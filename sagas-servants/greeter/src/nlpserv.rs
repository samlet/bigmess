// This file is generated by rust-protobuf 2.5.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct NlCabochaToken {
    // message fields
    pub id: i32,
    pub additional_info: ::std::string::String,
    pub feature_list: ::protobuf::RepeatedField<::std::string::String>,
    pub ne: ::std::string::String,
    pub normalized_surface: ::std::string::String,
    pub surface: ::std::string::String,
    pub pos: ::std::string::String,
    pub pos1: ::std::string::String,
    pub pos2: ::std::string::String,
    pub pos3: ::std::string::String,
    pub ctype: ::std::string::String,
    pub cform: ::std::string::String,
    pub genkei: ::std::string::String,
    pub yomi: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlCabochaToken {
    fn default() -> &'a NlCabochaToken {
        <NlCabochaToken as ::protobuf::Message>::default_instance()
    }
}

impl NlCabochaToken {
    pub fn new() -> NlCabochaToken {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // string additional_info = 2;


    pub fn get_additional_info(&self) -> &str {
        &self.additional_info
    }
    pub fn clear_additional_info(&mut self) {
        self.additional_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_info(&mut self, v: ::std::string::String) {
        self.additional_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additional_info(&mut self) -> &mut ::std::string::String {
        &mut self.additional_info
    }

    // Take field
    pub fn take_additional_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.additional_info, ::std::string::String::new())
    }

    // repeated string feature_list = 3;


    pub fn get_feature_list(&self) -> &[::std::string::String] {
        &self.feature_list
    }
    pub fn clear_feature_list(&mut self) {
        self.feature_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_feature_list(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.feature_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_feature_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.feature_list
    }

    // Take field
    pub fn take_feature_list(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.feature_list, ::protobuf::RepeatedField::new())
    }

    // string ne = 4;


    pub fn get_ne(&self) -> &str {
        &self.ne
    }
    pub fn clear_ne(&mut self) {
        self.ne.clear();
    }

    // Param is passed by value, moved
    pub fn set_ne(&mut self, v: ::std::string::String) {
        self.ne = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ne(&mut self) -> &mut ::std::string::String {
        &mut self.ne
    }

    // Take field
    pub fn take_ne(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ne, ::std::string::String::new())
    }

    // string normalized_surface = 5;


    pub fn get_normalized_surface(&self) -> &str {
        &self.normalized_surface
    }
    pub fn clear_normalized_surface(&mut self) {
        self.normalized_surface.clear();
    }

    // Param is passed by value, moved
    pub fn set_normalized_surface(&mut self, v: ::std::string::String) {
        self.normalized_surface = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_normalized_surface(&mut self) -> &mut ::std::string::String {
        &mut self.normalized_surface
    }

    // Take field
    pub fn take_normalized_surface(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.normalized_surface, ::std::string::String::new())
    }

    // string surface = 6;


    pub fn get_surface(&self) -> &str {
        &self.surface
    }
    pub fn clear_surface(&mut self) {
        self.surface.clear();
    }

    // Param is passed by value, moved
    pub fn set_surface(&mut self, v: ::std::string::String) {
        self.surface = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_surface(&mut self) -> &mut ::std::string::String {
        &mut self.surface
    }

    // Take field
    pub fn take_surface(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.surface, ::std::string::String::new())
    }

    // string pos = 7;


    pub fn get_pos(&self) -> &str {
        &self.pos
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: ::std::string::String) {
        self.pos = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut ::std::string::String {
        &mut self.pos
    }

    // Take field
    pub fn take_pos(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pos, ::std::string::String::new())
    }

    // string pos1 = 8;


    pub fn get_pos1(&self) -> &str {
        &self.pos1
    }
    pub fn clear_pos1(&mut self) {
        self.pos1.clear();
    }

    // Param is passed by value, moved
    pub fn set_pos1(&mut self, v: ::std::string::String) {
        self.pos1 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos1(&mut self) -> &mut ::std::string::String {
        &mut self.pos1
    }

    // Take field
    pub fn take_pos1(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pos1, ::std::string::String::new())
    }

    // string pos2 = 9;


    pub fn get_pos2(&self) -> &str {
        &self.pos2
    }
    pub fn clear_pos2(&mut self) {
        self.pos2.clear();
    }

    // Param is passed by value, moved
    pub fn set_pos2(&mut self, v: ::std::string::String) {
        self.pos2 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos2(&mut self) -> &mut ::std::string::String {
        &mut self.pos2
    }

    // Take field
    pub fn take_pos2(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pos2, ::std::string::String::new())
    }

    // string pos3 = 10;


    pub fn get_pos3(&self) -> &str {
        &self.pos3
    }
    pub fn clear_pos3(&mut self) {
        self.pos3.clear();
    }

    // Param is passed by value, moved
    pub fn set_pos3(&mut self, v: ::std::string::String) {
        self.pos3 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos3(&mut self) -> &mut ::std::string::String {
        &mut self.pos3
    }

    // Take field
    pub fn take_pos3(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pos3, ::std::string::String::new())
    }

    // string ctype = 11;


    pub fn get_ctype(&self) -> &str {
        &self.ctype
    }
    pub fn clear_ctype(&mut self) {
        self.ctype.clear();
    }

    // Param is passed by value, moved
    pub fn set_ctype(&mut self, v: ::std::string::String) {
        self.ctype = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ctype(&mut self) -> &mut ::std::string::String {
        &mut self.ctype
    }

    // Take field
    pub fn take_ctype(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ctype, ::std::string::String::new())
    }

    // string cform = 12;


    pub fn get_cform(&self) -> &str {
        &self.cform
    }
    pub fn clear_cform(&mut self) {
        self.cform.clear();
    }

    // Param is passed by value, moved
    pub fn set_cform(&mut self, v: ::std::string::String) {
        self.cform = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cform(&mut self) -> &mut ::std::string::String {
        &mut self.cform
    }

    // Take field
    pub fn take_cform(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cform, ::std::string::String::new())
    }

    // string genkei = 13;


    pub fn get_genkei(&self) -> &str {
        &self.genkei
    }
    pub fn clear_genkei(&mut self) {
        self.genkei.clear();
    }

    // Param is passed by value, moved
    pub fn set_genkei(&mut self, v: ::std::string::String) {
        self.genkei = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_genkei(&mut self) -> &mut ::std::string::String {
        &mut self.genkei
    }

    // Take field
    pub fn take_genkei(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.genkei, ::std::string::String::new())
    }

    // string yomi = 14;


    pub fn get_yomi(&self) -> &str {
        &self.yomi
    }
    pub fn clear_yomi(&mut self) {
        self.yomi.clear();
    }

    // Param is passed by value, moved
    pub fn set_yomi(&mut self, v: ::std::string::String) {
        self.yomi = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_yomi(&mut self) -> &mut ::std::string::String {
        &mut self.yomi
    }

    // Take field
    pub fn take_yomi(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.yomi, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NlCabochaToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.additional_info)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.feature_list)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ne)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.normalized_surface)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.surface)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pos)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pos1)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pos2)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pos3)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ctype)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cform)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.genkei)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.yomi)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.additional_info.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.additional_info);
        }
        for value in &self.feature_list {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.ne.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.ne);
        }
        if !self.normalized_surface.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.normalized_surface);
        }
        if !self.surface.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.surface);
        }
        if !self.pos.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.pos);
        }
        if !self.pos1.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.pos1);
        }
        if !self.pos2.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.pos2);
        }
        if !self.pos3.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.pos3);
        }
        if !self.ctype.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.ctype);
        }
        if !self.cform.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.cform);
        }
        if !self.genkei.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.genkei);
        }
        if !self.yomi.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.yomi);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.additional_info.is_empty() {
            os.write_string(2, &self.additional_info)?;
        }
        for v in &self.feature_list {
            os.write_string(3, &v)?;
        };
        if !self.ne.is_empty() {
            os.write_string(4, &self.ne)?;
        }
        if !self.normalized_surface.is_empty() {
            os.write_string(5, &self.normalized_surface)?;
        }
        if !self.surface.is_empty() {
            os.write_string(6, &self.surface)?;
        }
        if !self.pos.is_empty() {
            os.write_string(7, &self.pos)?;
        }
        if !self.pos1.is_empty() {
            os.write_string(8, &self.pos1)?;
        }
        if !self.pos2.is_empty() {
            os.write_string(9, &self.pos2)?;
        }
        if !self.pos3.is_empty() {
            os.write_string(10, &self.pos3)?;
        }
        if !self.ctype.is_empty() {
            os.write_string(11, &self.ctype)?;
        }
        if !self.cform.is_empty() {
            os.write_string(12, &self.cform)?;
        }
        if !self.genkei.is_empty() {
            os.write_string(13, &self.genkei)?;
        }
        if !self.yomi.is_empty() {
            os.write_string(14, &self.yomi)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlCabochaToken {
        NlCabochaToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "id",
                    |m: &NlCabochaToken| { &m.id },
                    |m: &mut NlCabochaToken| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "additional_info",
                    |m: &NlCabochaToken| { &m.additional_info },
                    |m: &mut NlCabochaToken| { &mut m.additional_info },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "feature_list",
                    |m: &NlCabochaToken| { &m.feature_list },
                    |m: &mut NlCabochaToken| { &mut m.feature_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ne",
                    |m: &NlCabochaToken| { &m.ne },
                    |m: &mut NlCabochaToken| { &mut m.ne },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "normalized_surface",
                    |m: &NlCabochaToken| { &m.normalized_surface },
                    |m: &mut NlCabochaToken| { &mut m.normalized_surface },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "surface",
                    |m: &NlCabochaToken| { &m.surface },
                    |m: &mut NlCabochaToken| { &mut m.surface },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pos",
                    |m: &NlCabochaToken| { &m.pos },
                    |m: &mut NlCabochaToken| { &mut m.pos },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pos1",
                    |m: &NlCabochaToken| { &m.pos1 },
                    |m: &mut NlCabochaToken| { &mut m.pos1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pos2",
                    |m: &NlCabochaToken| { &m.pos2 },
                    |m: &mut NlCabochaToken| { &mut m.pos2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pos3",
                    |m: &NlCabochaToken| { &m.pos3 },
                    |m: &mut NlCabochaToken| { &mut m.pos3 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ctype",
                    |m: &NlCabochaToken| { &m.ctype },
                    |m: &mut NlCabochaToken| { &mut m.ctype },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cform",
                    |m: &NlCabochaToken| { &m.cform },
                    |m: &mut NlCabochaToken| { &mut m.cform },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "genkei",
                    |m: &NlCabochaToken| { &m.genkei },
                    |m: &mut NlCabochaToken| { &mut m.genkei },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "yomi",
                    |m: &NlCabochaToken| { &m.yomi },
                    |m: &mut NlCabochaToken| { &mut m.yomi },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlCabochaToken>(
                    "NlCabochaToken",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlCabochaToken {
        static mut instance: ::protobuf::lazy::Lazy<NlCabochaToken> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlCabochaToken,
        };
        unsafe {
            instance.get(NlCabochaToken::new)
        }
    }
}

impl ::protobuf::Clear for NlCabochaToken {
    fn clear(&mut self) {
        self.id = 0;
        self.additional_info.clear();
        self.feature_list.clear();
        self.ne.clear();
        self.normalized_surface.clear();
        self.surface.clear();
        self.pos.clear();
        self.pos1.clear();
        self.pos2.clear();
        self.pos3.clear();
        self.ctype.clear();
        self.cform.clear();
        self.genkei.clear();
        self.yomi.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlCabochaToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlCabochaToken {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlCabochaChunk {
    // message fields
    pub id: i32,
    pub additional_info: ::std::string::String,
    pub feature_list: ::protobuf::RepeatedField<::std::string::String>,
    pub func_pos: i32,
    pub head_pos: i32,
    pub link: i32,
    pub score: f32,
    pub token_pos: i32,
    pub next_link_id: i32,
    pub prev_link_ids: ::std::vec::Vec<i32>,
    pub tokens: ::protobuf::RepeatedField<NlCabochaToken>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlCabochaChunk {
    fn default() -> &'a NlCabochaChunk {
        <NlCabochaChunk as ::protobuf::Message>::default_instance()
    }
}

impl NlCabochaChunk {
    pub fn new() -> NlCabochaChunk {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // string additional_info = 2;


    pub fn get_additional_info(&self) -> &str {
        &self.additional_info
    }
    pub fn clear_additional_info(&mut self) {
        self.additional_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_info(&mut self, v: ::std::string::String) {
        self.additional_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additional_info(&mut self) -> &mut ::std::string::String {
        &mut self.additional_info
    }

    // Take field
    pub fn take_additional_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.additional_info, ::std::string::String::new())
    }

    // repeated string feature_list = 3;


    pub fn get_feature_list(&self) -> &[::std::string::String] {
        &self.feature_list
    }
    pub fn clear_feature_list(&mut self) {
        self.feature_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_feature_list(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.feature_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_feature_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.feature_list
    }

    // Take field
    pub fn take_feature_list(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.feature_list, ::protobuf::RepeatedField::new())
    }

    // int32 func_pos = 4;


    pub fn get_func_pos(&self) -> i32 {
        self.func_pos
    }
    pub fn clear_func_pos(&mut self) {
        self.func_pos = 0;
    }

    // Param is passed by value, moved
    pub fn set_func_pos(&mut self, v: i32) {
        self.func_pos = v;
    }

    // int32 head_pos = 5;


    pub fn get_head_pos(&self) -> i32 {
        self.head_pos
    }
    pub fn clear_head_pos(&mut self) {
        self.head_pos = 0;
    }

    // Param is passed by value, moved
    pub fn set_head_pos(&mut self, v: i32) {
        self.head_pos = v;
    }

    // int32 link = 6;


    pub fn get_link(&self) -> i32 {
        self.link
    }
    pub fn clear_link(&mut self) {
        self.link = 0;
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: i32) {
        self.link = v;
    }

    // float score = 7;


    pub fn get_score(&self) -> f32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = v;
    }

    // int32 token_pos = 8;


    pub fn get_token_pos(&self) -> i32 {
        self.token_pos
    }
    pub fn clear_token_pos(&mut self) {
        self.token_pos = 0;
    }

    // Param is passed by value, moved
    pub fn set_token_pos(&mut self, v: i32) {
        self.token_pos = v;
    }

    // int32 next_link_id = 9;


    pub fn get_next_link_id(&self) -> i32 {
        self.next_link_id
    }
    pub fn clear_next_link_id(&mut self) {
        self.next_link_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_link_id(&mut self, v: i32) {
        self.next_link_id = v;
    }

    // repeated int32 prev_link_ids = 10;


    pub fn get_prev_link_ids(&self) -> &[i32] {
        &self.prev_link_ids
    }
    pub fn clear_prev_link_ids(&mut self) {
        self.prev_link_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_prev_link_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.prev_link_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prev_link_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.prev_link_ids
    }

    // Take field
    pub fn take_prev_link_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.prev_link_ids, ::std::vec::Vec::new())
    }

    // repeated .nlpserv.NlCabochaToken tokens = 11;


    pub fn get_tokens(&self) -> &[NlCabochaToken] {
        &self.tokens
    }
    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::protobuf::RepeatedField<NlCabochaToken>) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tokens(&mut self) -> &mut ::protobuf::RepeatedField<NlCabochaToken> {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::protobuf::RepeatedField<NlCabochaToken> {
        ::std::mem::replace(&mut self.tokens, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NlCabochaChunk {
    fn is_initialized(&self) -> bool {
        for v in &self.tokens {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.additional_info)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.feature_list)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.func_pos = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.head_pos = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.link = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.token_pos = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.next_link_id = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.prev_link_ids)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tokens)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.additional_info.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.additional_info);
        }
        for value in &self.feature_list {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.func_pos != 0 {
            my_size += ::protobuf::rt::value_size(4, self.func_pos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.head_pos != 0 {
            my_size += ::protobuf::rt::value_size(5, self.head_pos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.link != 0 {
            my_size += ::protobuf::rt::value_size(6, self.link, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.score != 0. {
            my_size += 5;
        }
        if self.token_pos != 0 {
            my_size += ::protobuf::rt::value_size(8, self.token_pos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.next_link_id != 0 {
            my_size += ::protobuf::rt::value_size(9, self.next_link_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.prev_link_ids {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.additional_info.is_empty() {
            os.write_string(2, &self.additional_info)?;
        }
        for v in &self.feature_list {
            os.write_string(3, &v)?;
        };
        if self.func_pos != 0 {
            os.write_int32(4, self.func_pos)?;
        }
        if self.head_pos != 0 {
            os.write_int32(5, self.head_pos)?;
        }
        if self.link != 0 {
            os.write_int32(6, self.link)?;
        }
        if self.score != 0. {
            os.write_float(7, self.score)?;
        }
        if self.token_pos != 0 {
            os.write_int32(8, self.token_pos)?;
        }
        if self.next_link_id != 0 {
            os.write_int32(9, self.next_link_id)?;
        }
        for v in &self.prev_link_ids {
            os.write_int32(10, *v)?;
        };
        for v in &self.tokens {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlCabochaChunk {
        NlCabochaChunk::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "id",
                    |m: &NlCabochaChunk| { &m.id },
                    |m: &mut NlCabochaChunk| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "additional_info",
                    |m: &NlCabochaChunk| { &m.additional_info },
                    |m: &mut NlCabochaChunk| { &mut m.additional_info },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "feature_list",
                    |m: &NlCabochaChunk| { &m.feature_list },
                    |m: &mut NlCabochaChunk| { &mut m.feature_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "func_pos",
                    |m: &NlCabochaChunk| { &m.func_pos },
                    |m: &mut NlCabochaChunk| { &mut m.func_pos },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "head_pos",
                    |m: &NlCabochaChunk| { &m.head_pos },
                    |m: &mut NlCabochaChunk| { &mut m.head_pos },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "link",
                    |m: &NlCabochaChunk| { &m.link },
                    |m: &mut NlCabochaChunk| { &mut m.link },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "score",
                    |m: &NlCabochaChunk| { &m.score },
                    |m: &mut NlCabochaChunk| { &mut m.score },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "token_pos",
                    |m: &NlCabochaChunk| { &m.token_pos },
                    |m: &mut NlCabochaChunk| { &mut m.token_pos },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "next_link_id",
                    |m: &NlCabochaChunk| { &m.next_link_id },
                    |m: &mut NlCabochaChunk| { &mut m.next_link_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "prev_link_ids",
                    |m: &NlCabochaChunk| { &m.prev_link_ids },
                    |m: &mut NlCabochaChunk| { &mut m.prev_link_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NlCabochaToken>>(
                    "tokens",
                    |m: &NlCabochaChunk| { &m.tokens },
                    |m: &mut NlCabochaChunk| { &mut m.tokens },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlCabochaChunk>(
                    "NlCabochaChunk",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlCabochaChunk {
        static mut instance: ::protobuf::lazy::Lazy<NlCabochaChunk> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlCabochaChunk,
        };
        unsafe {
            instance.get(NlCabochaChunk::new)
        }
    }
}

impl ::protobuf::Clear for NlCabochaChunk {
    fn clear(&mut self) {
        self.id = 0;
        self.additional_info.clear();
        self.feature_list.clear();
        self.func_pos = 0;
        self.head_pos = 0;
        self.link = 0;
        self.score = 0.;
        self.token_pos = 0;
        self.next_link_id = 0;
        self.prev_link_ids.clear();
        self.tokens.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlCabochaChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlCabochaChunk {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlCabochaChunks {
    // message fields
    pub chunks: ::protobuf::RepeatedField<NlCabochaChunk>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlCabochaChunks {
    fn default() -> &'a NlCabochaChunks {
        <NlCabochaChunks as ::protobuf::Message>::default_instance()
    }
}

impl NlCabochaChunks {
    pub fn new() -> NlCabochaChunks {
        ::std::default::Default::default()
    }

    // repeated .nlpserv.NlCabochaChunk chunks = 1;


    pub fn get_chunks(&self) -> &[NlCabochaChunk] {
        &self.chunks
    }
    pub fn clear_chunks(&mut self) {
        self.chunks.clear();
    }

    // Param is passed by value, moved
    pub fn set_chunks(&mut self, v: ::protobuf::RepeatedField<NlCabochaChunk>) {
        self.chunks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chunks(&mut self) -> &mut ::protobuf::RepeatedField<NlCabochaChunk> {
        &mut self.chunks
    }

    // Take field
    pub fn take_chunks(&mut self) -> ::protobuf::RepeatedField<NlCabochaChunk> {
        ::std::mem::replace(&mut self.chunks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NlCabochaChunks {
    fn is_initialized(&self) -> bool {
        for v in &self.chunks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chunks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chunks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chunks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlCabochaChunks {
        NlCabochaChunks::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NlCabochaChunk>>(
                    "chunks",
                    |m: &NlCabochaChunks| { &m.chunks },
                    |m: &mut NlCabochaChunks| { &mut m.chunks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlCabochaChunks>(
                    "NlCabochaChunks",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlCabochaChunks {
        static mut instance: ::protobuf::lazy::Lazy<NlCabochaChunks> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlCabochaChunks,
        };
        unsafe {
            instance.get(NlCabochaChunks::new)
        }
    }
}

impl ::protobuf::Clear for NlCabochaChunks {
    fn clear(&mut self) {
        self.chunks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlCabochaChunks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlCabochaChunks {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlEntity {
    // message fields
    pub entity: ::std::string::String,
    pub value: ::std::string::String,
    pub start: i32,
    pub confidence: f32,
    pub end: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlEntity {
    fn default() -> &'a NlEntity {
        <NlEntity as ::protobuf::Message>::default_instance()
    }
}

impl NlEntity {
    pub fn new() -> NlEntity {
        ::std::default::Default::default()
    }

    // string entity = 1;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // int32 start = 3;


    pub fn get_start(&self) -> i32 {
        self.start
    }
    pub fn clear_start(&mut self) {
        self.start = 0;
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = v;
    }

    // float confidence = 4;


    pub fn get_confidence(&self) -> f32 {
        self.confidence
    }
    pub fn clear_confidence(&mut self) {
        self.confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_confidence(&mut self, v: f32) {
        self.confidence = v;
    }

    // int32 end = 5;


    pub fn get_end(&self) -> i32 {
        self.end
    }
    pub fn clear_end(&mut self) {
        self.end = 0;
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i32) {
        self.end = v;
    }
}

impl ::protobuf::Message for NlEntity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.confidence = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.end = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        if self.start != 0 {
            my_size += ::protobuf::rt::value_size(3, self.start, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.confidence != 0. {
            my_size += 5;
        }
        if self.end != 0 {
            my_size += ::protobuf::rt::value_size(5, self.end, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.entity.is_empty() {
            os.write_string(1, &self.entity)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        if self.start != 0 {
            os.write_int32(3, self.start)?;
        }
        if self.confidence != 0. {
            os.write_float(4, self.confidence)?;
        }
        if self.end != 0 {
            os.write_int32(5, self.end)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlEntity {
        NlEntity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "entity",
                    |m: &NlEntity| { &m.entity },
                    |m: &mut NlEntity| { &mut m.entity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &NlEntity| { &m.value },
                    |m: &mut NlEntity| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "start",
                    |m: &NlEntity| { &m.start },
                    |m: &mut NlEntity| { &mut m.start },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "confidence",
                    |m: &NlEntity| { &m.confidence },
                    |m: &mut NlEntity| { &mut m.confidence },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "end",
                    |m: &NlEntity| { &m.end },
                    |m: &mut NlEntity| { &mut m.end },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlEntity>(
                    "NlEntity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlEntity {
        static mut instance: ::protobuf::lazy::Lazy<NlEntity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlEntity,
        };
        unsafe {
            instance.get(NlEntity::new)
        }
    }
}

impl ::protobuf::Clear for NlEntity {
    fn clear(&mut self) {
        self.entity.clear();
        self.value.clear();
        self.start = 0;
        self.confidence = 0.;
        self.end = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlEntity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlEntity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlEntities {
    // message fields
    pub entities: ::protobuf::RepeatedField<NlEntity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlEntities {
    fn default() -> &'a NlEntities {
        <NlEntities as ::protobuf::Message>::default_instance()
    }
}

impl NlEntities {
    pub fn new() -> NlEntities {
        ::std::default::Default::default()
    }

    // repeated .nlpserv.NlEntity entities = 1;


    pub fn get_entities(&self) -> &[NlEntity] {
        &self.entities
    }
    pub fn clear_entities(&mut self) {
        self.entities.clear();
    }

    // Param is passed by value, moved
    pub fn set_entities(&mut self, v: ::protobuf::RepeatedField<NlEntity>) {
        self.entities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entities(&mut self) -> &mut ::protobuf::RepeatedField<NlEntity> {
        &mut self.entities
    }

    // Take field
    pub fn take_entities(&mut self) -> ::protobuf::RepeatedField<NlEntity> {
        ::std::mem::replace(&mut self.entities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NlEntities {
    fn is_initialized(&self) -> bool {
        for v in &self.entities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entities {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlEntities {
        NlEntities::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NlEntity>>(
                    "entities",
                    |m: &NlEntities| { &m.entities },
                    |m: &mut NlEntities| { &mut m.entities },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlEntities>(
                    "NlEntities",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlEntities {
        static mut instance: ::protobuf::lazy::Lazy<NlEntities> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlEntities,
        };
        unsafe {
            instance.get(NlEntities::new)
        }
    }
}

impl ::protobuf::Clear for NlEntities {
    fn clear(&mut self) {
        self.entities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlEntities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlEntities {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlAmount {
    // message fields
    pub entity: ::protobuf::SingularPtrField<NlEntity>,
    pub numericVal: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlAmount {
    fn default() -> &'a NlAmount {
        <NlAmount as ::protobuf::Message>::default_instance()
    }
}

impl NlAmount {
    pub fn new() -> NlAmount {
        ::std::default::Default::default()
    }

    // .nlpserv.NlEntity entity = 1;


    pub fn get_entity(&self) -> &NlEntity {
        self.entity.as_ref().unwrap_or_else(|| NlEntity::default_instance())
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: NlEntity) {
        self.entity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut NlEntity {
        if self.entity.is_none() {
            self.entity.set_default();
        }
        self.entity.as_mut().unwrap()
    }

    // Take field
    pub fn take_entity(&mut self) -> NlEntity {
        self.entity.take().unwrap_or_else(|| NlEntity::new())
    }

    // string numericVal = 2;


    pub fn get_numericVal(&self) -> &str {
        &self.numericVal
    }
    pub fn clear_numericVal(&mut self) {
        self.numericVal.clear();
    }

    // Param is passed by value, moved
    pub fn set_numericVal(&mut self, v: ::std::string::String) {
        self.numericVal = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_numericVal(&mut self) -> &mut ::std::string::String {
        &mut self.numericVal
    }

    // Take field
    pub fn take_numericVal(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.numericVal, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NlAmount {
    fn is_initialized(&self) -> bool {
        for v in &self.entity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.entity)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.numericVal)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.entity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.numericVal.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.numericVal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.entity.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.numericVal.is_empty() {
            os.write_string(2, &self.numericVal)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlAmount {
        NlAmount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NlEntity>>(
                    "entity",
                    |m: &NlAmount| { &m.entity },
                    |m: &mut NlAmount| { &mut m.entity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "numericVal",
                    |m: &NlAmount| { &m.numericVal },
                    |m: &mut NlAmount| { &mut m.numericVal },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlAmount>(
                    "NlAmount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlAmount {
        static mut instance: ::protobuf::lazy::Lazy<NlAmount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlAmount,
        };
        unsafe {
            instance.get(NlAmount::new)
        }
    }
}

impl ::protobuf::Clear for NlAmount {
    fn clear(&mut self) {
        self.entity.clear();
        self.numericVal.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlAmount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlAmount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlAmountList {
    // message fields
    pub amount: ::protobuf::RepeatedField<NlAmount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlAmountList {
    fn default() -> &'a NlAmountList {
        <NlAmountList as ::protobuf::Message>::default_instance()
    }
}

impl NlAmountList {
    pub fn new() -> NlAmountList {
        ::std::default::Default::default()
    }

    // repeated .nlpserv.NlAmount amount = 1;


    pub fn get_amount(&self) -> &[NlAmount] {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::protobuf::RepeatedField<NlAmount>) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    pub fn mut_amount(&mut self) -> &mut ::protobuf::RepeatedField<NlAmount> {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::protobuf::RepeatedField<NlAmount> {
        ::std::mem::replace(&mut self.amount, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NlAmountList {
    fn is_initialized(&self) -> bool {
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.amount {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.amount {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlAmountList {
        NlAmountList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NlAmount>>(
                    "amount",
                    |m: &NlAmountList| { &m.amount },
                    |m: &mut NlAmountList| { &mut m.amount },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlAmountList>(
                    "NlAmountList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlAmountList {
        static mut instance: ::protobuf::lazy::Lazy<NlAmountList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlAmountList,
        };
        unsafe {
            instance.get(NlAmountList::new)
        }
    }
}

impl ::protobuf::Clear for NlAmountList {
    fn clear(&mut self) {
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlAmountList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlAmountList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlTokenizerRequest {
    // message fields
    pub text: ::protobuf::SingularPtrField<NlText>,
    pub options: ::protobuf::SingularPtrField<NlTokenizerOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlTokenizerRequest {
    fn default() -> &'a NlTokenizerRequest {
        <NlTokenizerRequest as ::protobuf::Message>::default_instance()
    }
}

impl NlTokenizerRequest {
    pub fn new() -> NlTokenizerRequest {
        ::std::default::Default::default()
    }

    // .nlpserv.NlText text = 1;


    pub fn get_text(&self) -> &NlText {
        self.text.as_ref().unwrap_or_else(|| NlText::default_instance())
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: NlText) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut NlText {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> NlText {
        self.text.take().unwrap_or_else(|| NlText::new())
    }

    // .nlpserv.NlTokenizerOptions options = 2;


    pub fn get_options(&self) -> &NlTokenizerOptions {
        self.options.as_ref().unwrap_or_else(|| NlTokenizerOptions::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: NlTokenizerOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut NlTokenizerOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> NlTokenizerOptions {
        self.options.take().unwrap_or_else(|| NlTokenizerOptions::new())
    }
}

impl ::protobuf::Message for NlTokenizerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlTokenizerRequest {
        NlTokenizerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NlText>>(
                    "text",
                    |m: &NlTokenizerRequest| { &m.text },
                    |m: &mut NlTokenizerRequest| { &mut m.text },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NlTokenizerOptions>>(
                    "options",
                    |m: &NlTokenizerRequest| { &m.options },
                    |m: &mut NlTokenizerRequest| { &mut m.options },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlTokenizerRequest>(
                    "NlTokenizerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlTokenizerRequest {
        static mut instance: ::protobuf::lazy::Lazy<NlTokenizerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlTokenizerRequest,
        };
        unsafe {
            instance.get(NlTokenizerRequest::new)
        }
    }
}

impl ::protobuf::Clear for NlTokenizerRequest {
    fn clear(&mut self) {
        self.text.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlTokenizerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlTokenizerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlToken {
    // message fields
    pub text: ::std::string::String,
    pub length: i32,
    pub label: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlToken {
    fn default() -> &'a NlToken {
        <NlToken as ::protobuf::Message>::default_instance()
    }
}

impl NlToken {
    pub fn new() -> NlToken {
        ::std::default::Default::default()
    }

    // string text = 1;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }

    // int32 length = 2;


    pub fn get_length(&self) -> i32 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = v;
    }

    // string label = 3;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NlToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.length = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.text);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(2, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.text.is_empty() {
            os.write_string(1, &self.text)?;
        }
        if self.length != 0 {
            os.write_int32(2, self.length)?;
        }
        if !self.label.is_empty() {
            os.write_string(3, &self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlToken {
        NlToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &NlToken| { &m.text },
                    |m: &mut NlToken| { &mut m.text },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "length",
                    |m: &NlToken| { &m.length },
                    |m: &mut NlToken| { &mut m.length },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &NlToken| { &m.label },
                    |m: &mut NlToken| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlToken>(
                    "NlToken",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlToken {
        static mut instance: ::protobuf::lazy::Lazy<NlToken> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlToken,
        };
        unsafe {
            instance.get(NlToken::new)
        }
    }
}

impl ::protobuf::Clear for NlToken {
    fn clear(&mut self) {
        self.text.clear();
        self.length = 0;
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlToken {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlTokens {
    // message fields
    pub tokens: ::protobuf::RepeatedField<NlToken>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlTokens {
    fn default() -> &'a NlTokens {
        <NlTokens as ::protobuf::Message>::default_instance()
    }
}

impl NlTokens {
    pub fn new() -> NlTokens {
        ::std::default::Default::default()
    }

    // repeated .nlpserv.NlToken tokens = 1;


    pub fn get_tokens(&self) -> &[NlToken] {
        &self.tokens
    }
    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::protobuf::RepeatedField<NlToken>) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tokens(&mut self) -> &mut ::protobuf::RepeatedField<NlToken> {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::protobuf::RepeatedField<NlToken> {
        ::std::mem::replace(&mut self.tokens, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NlTokens {
    fn is_initialized(&self) -> bool {
        for v in &self.tokens {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tokens)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tokens {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlTokens {
        NlTokens::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NlToken>>(
                    "tokens",
                    |m: &NlTokens| { &m.tokens },
                    |m: &mut NlTokens| { &mut m.tokens },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlTokens>(
                    "NlTokens",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlTokens {
        static mut instance: ::protobuf::lazy::Lazy<NlTokens> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlTokens,
        };
        unsafe {
            instance.get(NlTokens::new)
        }
    }
}

impl ::protobuf::Clear for NlTokens {
    fn clear(&mut self) {
        self.tokens.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlTokens {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlTokens {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlTokenizerOptions {
    // message fields
    pub japaneseNameRecognize: bool,
    pub placeRecognize: bool,
    pub organizationRecognize: bool,
    pub nameRecognize: bool,
    pub translatedNameRecognize: bool,
    pub numberQuantifierRecognize: bool,
    pub allNamedEntityRecognize: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlTokenizerOptions {
    fn default() -> &'a NlTokenizerOptions {
        <NlTokenizerOptions as ::protobuf::Message>::default_instance()
    }
}

impl NlTokenizerOptions {
    pub fn new() -> NlTokenizerOptions {
        ::std::default::Default::default()
    }

    // bool japaneseNameRecognize = 1;


    pub fn get_japaneseNameRecognize(&self) -> bool {
        self.japaneseNameRecognize
    }
    pub fn clear_japaneseNameRecognize(&mut self) {
        self.japaneseNameRecognize = false;
    }

    // Param is passed by value, moved
    pub fn set_japaneseNameRecognize(&mut self, v: bool) {
        self.japaneseNameRecognize = v;
    }

    // bool placeRecognize = 2;


    pub fn get_placeRecognize(&self) -> bool {
        self.placeRecognize
    }
    pub fn clear_placeRecognize(&mut self) {
        self.placeRecognize = false;
    }

    // Param is passed by value, moved
    pub fn set_placeRecognize(&mut self, v: bool) {
        self.placeRecognize = v;
    }

    // bool organizationRecognize = 3;


    pub fn get_organizationRecognize(&self) -> bool {
        self.organizationRecognize
    }
    pub fn clear_organizationRecognize(&mut self) {
        self.organizationRecognize = false;
    }

    // Param is passed by value, moved
    pub fn set_organizationRecognize(&mut self, v: bool) {
        self.organizationRecognize = v;
    }

    // bool nameRecognize = 4;


    pub fn get_nameRecognize(&self) -> bool {
        self.nameRecognize
    }
    pub fn clear_nameRecognize(&mut self) {
        self.nameRecognize = false;
    }

    // Param is passed by value, moved
    pub fn set_nameRecognize(&mut self, v: bool) {
        self.nameRecognize = v;
    }

    // bool translatedNameRecognize = 5;


    pub fn get_translatedNameRecognize(&self) -> bool {
        self.translatedNameRecognize
    }
    pub fn clear_translatedNameRecognize(&mut self) {
        self.translatedNameRecognize = false;
    }

    // Param is passed by value, moved
    pub fn set_translatedNameRecognize(&mut self, v: bool) {
        self.translatedNameRecognize = v;
    }

    // bool numberQuantifierRecognize = 6;


    pub fn get_numberQuantifierRecognize(&self) -> bool {
        self.numberQuantifierRecognize
    }
    pub fn clear_numberQuantifierRecognize(&mut self) {
        self.numberQuantifierRecognize = false;
    }

    // Param is passed by value, moved
    pub fn set_numberQuantifierRecognize(&mut self, v: bool) {
        self.numberQuantifierRecognize = v;
    }

    // bool allNamedEntityRecognize = 7;


    pub fn get_allNamedEntityRecognize(&self) -> bool {
        self.allNamedEntityRecognize
    }
    pub fn clear_allNamedEntityRecognize(&mut self) {
        self.allNamedEntityRecognize = false;
    }

    // Param is passed by value, moved
    pub fn set_allNamedEntityRecognize(&mut self, v: bool) {
        self.allNamedEntityRecognize = v;
    }
}

impl ::protobuf::Message for NlTokenizerOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.japaneseNameRecognize = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.placeRecognize = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.organizationRecognize = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.nameRecognize = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.translatedNameRecognize = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.numberQuantifierRecognize = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allNamedEntityRecognize = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.japaneseNameRecognize != false {
            my_size += 2;
        }
        if self.placeRecognize != false {
            my_size += 2;
        }
        if self.organizationRecognize != false {
            my_size += 2;
        }
        if self.nameRecognize != false {
            my_size += 2;
        }
        if self.translatedNameRecognize != false {
            my_size += 2;
        }
        if self.numberQuantifierRecognize != false {
            my_size += 2;
        }
        if self.allNamedEntityRecognize != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.japaneseNameRecognize != false {
            os.write_bool(1, self.japaneseNameRecognize)?;
        }
        if self.placeRecognize != false {
            os.write_bool(2, self.placeRecognize)?;
        }
        if self.organizationRecognize != false {
            os.write_bool(3, self.organizationRecognize)?;
        }
        if self.nameRecognize != false {
            os.write_bool(4, self.nameRecognize)?;
        }
        if self.translatedNameRecognize != false {
            os.write_bool(5, self.translatedNameRecognize)?;
        }
        if self.numberQuantifierRecognize != false {
            os.write_bool(6, self.numberQuantifierRecognize)?;
        }
        if self.allNamedEntityRecognize != false {
            os.write_bool(7, self.allNamedEntityRecognize)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlTokenizerOptions {
        NlTokenizerOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "japaneseNameRecognize",
                    |m: &NlTokenizerOptions| { &m.japaneseNameRecognize },
                    |m: &mut NlTokenizerOptions| { &mut m.japaneseNameRecognize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "placeRecognize",
                    |m: &NlTokenizerOptions| { &m.placeRecognize },
                    |m: &mut NlTokenizerOptions| { &mut m.placeRecognize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "organizationRecognize",
                    |m: &NlTokenizerOptions| { &m.organizationRecognize },
                    |m: &mut NlTokenizerOptions| { &mut m.organizationRecognize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "nameRecognize",
                    |m: &NlTokenizerOptions| { &m.nameRecognize },
                    |m: &mut NlTokenizerOptions| { &mut m.nameRecognize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "translatedNameRecognize",
                    |m: &NlTokenizerOptions| { &m.translatedNameRecognize },
                    |m: &mut NlTokenizerOptions| { &mut m.translatedNameRecognize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "numberQuantifierRecognize",
                    |m: &NlTokenizerOptions| { &m.numberQuantifierRecognize },
                    |m: &mut NlTokenizerOptions| { &mut m.numberQuantifierRecognize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allNamedEntityRecognize",
                    |m: &NlTokenizerOptions| { &m.allNamedEntityRecognize },
                    |m: &mut NlTokenizerOptions| { &mut m.allNamedEntityRecognize },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlTokenizerOptions>(
                    "NlTokenizerOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlTokenizerOptions {
        static mut instance: ::protobuf::lazy::Lazy<NlTokenizerOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlTokenizerOptions,
        };
        unsafe {
            instance.get(NlTokenizerOptions::new)
        }
    }
}

impl ::protobuf::Clear for NlTokenizerOptions {
    fn clear(&mut self) {
        self.japaneseNameRecognize = false;
        self.placeRecognize = false;
        self.organizationRecognize = false;
        self.nameRecognize = false;
        self.translatedNameRecognize = false;
        self.numberQuantifierRecognize = false;
        self.allNamedEntityRecognize = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlTokenizerOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlTokenizerOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlResult {
    // message fields
    pub code: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlResult {
    fn default() -> &'a NlResult {
        <NlResult as ::protobuf::Message>::default_instance()
    }
}

impl NlResult {
    pub fn new() -> NlResult {
        ::std::default::Default::default()
    }

    // int32 code = 1;


    pub fn get_code(&self) -> i32 {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: i32) {
        self.code = v;
    }
}

impl ::protobuf::Message for NlResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlResult {
        NlResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "code",
                    |m: &NlResult| { &m.code },
                    |m: &mut NlResult| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlResult>(
                    "NlResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlResult {
        static mut instance: ::protobuf::lazy::Lazy<NlResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlResult,
        };
        unsafe {
            instance.get(NlResult::new)
        }
    }
}

impl ::protobuf::Clear for NlResult {
    fn clear(&mut self) {
        self.code = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlText {
    // message fields
    pub text: ::std::string::String,
    pub lang: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlText {
    fn default() -> &'a NlText {
        <NlText as ::protobuf::Message>::default_instance()
    }
}

impl NlText {
    pub fn new() -> NlText {
        ::std::default::Default::default()
    }

    // string text = 1;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }

    // string lang = 2;


    pub fn get_lang(&self) -> &str {
        &self.lang
    }
    pub fn clear_lang(&mut self) {
        self.lang.clear();
    }

    // Param is passed by value, moved
    pub fn set_lang(&mut self, v: ::std::string::String) {
        self.lang = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lang(&mut self) -> &mut ::std::string::String {
        &mut self.lang
    }

    // Take field
    pub fn take_lang(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lang, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NlText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lang)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.text);
        }
        if !self.lang.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.lang);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.text.is_empty() {
            os.write_string(1, &self.text)?;
        }
        if !self.lang.is_empty() {
            os.write_string(2, &self.lang)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlText {
        NlText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &NlText| { &m.text },
                    |m: &mut NlText| { &mut m.text },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lang",
                    |m: &NlText| { &m.lang },
                    |m: &mut NlText| { &mut m.lang },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlText>(
                    "NlText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlText {
        static mut instance: ::protobuf::lazy::Lazy<NlText> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlText,
        };
        unsafe {
            instance.get(NlText::new)
        }
    }
}

impl ::protobuf::Clear for NlText {
    fn clear(&mut self) {
        self.text.clear();
        self.lang.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlText {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlWord {
    // message fields
    pub id: i32,
    pub lemma: ::std::string::String,
    pub postag1: ::std::string::String,
    pub postag2: ::std::string::String,
    pub head_id: i32,
    pub deprel: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlWord {
    fn default() -> &'a NlWord {
        <NlWord as ::protobuf::Message>::default_instance()
    }
}

impl NlWord {
    pub fn new() -> NlWord {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // string lemma = 2;


    pub fn get_lemma(&self) -> &str {
        &self.lemma
    }
    pub fn clear_lemma(&mut self) {
        self.lemma.clear();
    }

    // Param is passed by value, moved
    pub fn set_lemma(&mut self, v: ::std::string::String) {
        self.lemma = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lemma(&mut self) -> &mut ::std::string::String {
        &mut self.lemma
    }

    // Take field
    pub fn take_lemma(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lemma, ::std::string::String::new())
    }

    // string postag1 = 3;


    pub fn get_postag1(&self) -> &str {
        &self.postag1
    }
    pub fn clear_postag1(&mut self) {
        self.postag1.clear();
    }

    // Param is passed by value, moved
    pub fn set_postag1(&mut self, v: ::std::string::String) {
        self.postag1 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postag1(&mut self) -> &mut ::std::string::String {
        &mut self.postag1
    }

    // Take field
    pub fn take_postag1(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.postag1, ::std::string::String::new())
    }

    // string postag2 = 4;


    pub fn get_postag2(&self) -> &str {
        &self.postag2
    }
    pub fn clear_postag2(&mut self) {
        self.postag2.clear();
    }

    // Param is passed by value, moved
    pub fn set_postag2(&mut self, v: ::std::string::String) {
        self.postag2 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postag2(&mut self) -> &mut ::std::string::String {
        &mut self.postag2
    }

    // Take field
    pub fn take_postag2(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.postag2, ::std::string::String::new())
    }

    // int32 head_id = 5;


    pub fn get_head_id(&self) -> i32 {
        self.head_id
    }
    pub fn clear_head_id(&mut self) {
        self.head_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_head_id(&mut self, v: i32) {
        self.head_id = v;
    }

    // string deprel = 6;


    pub fn get_deprel(&self) -> &str {
        &self.deprel
    }
    pub fn clear_deprel(&mut self) {
        self.deprel.clear();
    }

    // Param is passed by value, moved
    pub fn set_deprel(&mut self, v: ::std::string::String) {
        self.deprel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deprel(&mut self) -> &mut ::std::string::String {
        &mut self.deprel
    }

    // Take field
    pub fn take_deprel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.deprel, ::std::string::String::new())
    }

    // string name = 7;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NlWord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lemma)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.postag1)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.postag2)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.head_id = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.deprel)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.lemma.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.lemma);
        }
        if !self.postag1.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.postag1);
        }
        if !self.postag2.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.postag2);
        }
        if self.head_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.head_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.deprel.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.deprel);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.lemma.is_empty() {
            os.write_string(2, &self.lemma)?;
        }
        if !self.postag1.is_empty() {
            os.write_string(3, &self.postag1)?;
        }
        if !self.postag2.is_empty() {
            os.write_string(4, &self.postag2)?;
        }
        if self.head_id != 0 {
            os.write_int32(5, self.head_id)?;
        }
        if !self.deprel.is_empty() {
            os.write_string(6, &self.deprel)?;
        }
        if !self.name.is_empty() {
            os.write_string(7, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlWord {
        NlWord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "id",
                    |m: &NlWord| { &m.id },
                    |m: &mut NlWord| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lemma",
                    |m: &NlWord| { &m.lemma },
                    |m: &mut NlWord| { &mut m.lemma },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "postag1",
                    |m: &NlWord| { &m.postag1 },
                    |m: &mut NlWord| { &mut m.postag1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "postag2",
                    |m: &NlWord| { &m.postag2 },
                    |m: &mut NlWord| { &mut m.postag2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "head_id",
                    |m: &NlWord| { &m.head_id },
                    |m: &mut NlWord| { &mut m.head_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "deprel",
                    |m: &NlWord| { &m.deprel },
                    |m: &mut NlWord| { &mut m.deprel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &NlWord| { &m.name },
                    |m: &mut NlWord| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlWord>(
                    "NlWord",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlWord {
        static mut instance: ::protobuf::lazy::Lazy<NlWord> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlWord,
        };
        unsafe {
            instance.get(NlWord::new)
        }
    }
}

impl ::protobuf::Clear for NlWord {
    fn clear(&mut self) {
        self.id = 0;
        self.lemma.clear();
        self.postag1.clear();
        self.postag2.clear();
        self.head_id = 0;
        self.deprel.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlWord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlWord {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlParseRequest {
    // message fields
    pub text: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlParseRequest {
    fn default() -> &'a NlParseRequest {
        <NlParseRequest as ::protobuf::Message>::default_instance()
    }
}

impl NlParseRequest {
    pub fn new() -> NlParseRequest {
        ::std::default::Default::default()
    }

    // string text = 1;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NlParseRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.text.is_empty() {
            os.write_string(1, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlParseRequest {
        NlParseRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &NlParseRequest| { &m.text },
                    |m: &mut NlParseRequest| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlParseRequest>(
                    "NlParseRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlParseRequest {
        static mut instance: ::protobuf::lazy::Lazy<NlParseRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlParseRequest,
        };
        unsafe {
            instance.get(NlParseRequest::new)
        }
    }
}

impl ::protobuf::Clear for NlParseRequest {
    fn clear(&mut self) {
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlParseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlParseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlPinyinRequest {
    // message fields
    pub text: ::std::string::String,
    pub presentation: NlPinyinRequest_PinyinPresentation,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlPinyinRequest {
    fn default() -> &'a NlPinyinRequest {
        <NlPinyinRequest as ::protobuf::Message>::default_instance()
    }
}

impl NlPinyinRequest {
    pub fn new() -> NlPinyinRequest {
        ::std::default::Default::default()
    }

    // string text = 1;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }

    // .nlpserv.NlPinyinRequest.PinyinPresentation presentation = 2;


    pub fn get_presentation(&self) -> NlPinyinRequest_PinyinPresentation {
        self.presentation
    }
    pub fn clear_presentation(&mut self) {
        self.presentation = NlPinyinRequest_PinyinPresentation::NUMBER;
    }

    // Param is passed by value, moved
    pub fn set_presentation(&mut self, v: NlPinyinRequest_PinyinPresentation) {
        self.presentation = v;
    }
}

impl ::protobuf::Message for NlPinyinRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.presentation, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.text);
        }
        if self.presentation != NlPinyinRequest_PinyinPresentation::NUMBER {
            my_size += ::protobuf::rt::enum_size(2, self.presentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.text.is_empty() {
            os.write_string(1, &self.text)?;
        }
        if self.presentation != NlPinyinRequest_PinyinPresentation::NUMBER {
            os.write_enum(2, self.presentation.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlPinyinRequest {
        NlPinyinRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &NlPinyinRequest| { &m.text },
                    |m: &mut NlPinyinRequest| { &mut m.text },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NlPinyinRequest_PinyinPresentation>>(
                    "presentation",
                    |m: &NlPinyinRequest| { &m.presentation },
                    |m: &mut NlPinyinRequest| { &mut m.presentation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlPinyinRequest>(
                    "NlPinyinRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlPinyinRequest {
        static mut instance: ::protobuf::lazy::Lazy<NlPinyinRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlPinyinRequest,
        };
        unsafe {
            instance.get(NlPinyinRequest::new)
        }
    }
}

impl ::protobuf::Clear for NlPinyinRequest {
    fn clear(&mut self) {
        self.text.clear();
        self.presentation = NlPinyinRequest_PinyinPresentation::NUMBER;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlPinyinRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlPinyinRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NlPinyinRequest_PinyinPresentation {
    NUMBER = 0,
    WITH_TONE_MARK = 1,
    WITHOUT_TONE = 2,
}

impl ::protobuf::ProtobufEnum for NlPinyinRequest_PinyinPresentation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NlPinyinRequest_PinyinPresentation> {
        match value {
            0 => ::std::option::Option::Some(NlPinyinRequest_PinyinPresentation::NUMBER),
            1 => ::std::option::Option::Some(NlPinyinRequest_PinyinPresentation::WITH_TONE_MARK),
            2 => ::std::option::Option::Some(NlPinyinRequest_PinyinPresentation::WITHOUT_TONE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NlPinyinRequest_PinyinPresentation] = &[
            NlPinyinRequest_PinyinPresentation::NUMBER,
            NlPinyinRequest_PinyinPresentation::WITH_TONE_MARK,
            NlPinyinRequest_PinyinPresentation::WITHOUT_TONE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NlPinyinRequest_PinyinPresentation", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NlPinyinRequest_PinyinPresentation {
}

impl ::std::default::Default for NlPinyinRequest_PinyinPresentation {
    fn default() -> Self {
        NlPinyinRequest_PinyinPresentation::NUMBER
    }
}

impl ::protobuf::reflect::ProtobufValue for NlPinyinRequest_PinyinPresentation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlSentence {
    // message fields
    pub words: ::protobuf::RepeatedField<NlWord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlSentence {
    fn default() -> &'a NlSentence {
        <NlSentence as ::protobuf::Message>::default_instance()
    }
}

impl NlSentence {
    pub fn new() -> NlSentence {
        ::std::default::Default::default()
    }

    // repeated .nlpserv.NlWord words = 1;


    pub fn get_words(&self) -> &[NlWord] {
        &self.words
    }
    pub fn clear_words(&mut self) {
        self.words.clear();
    }

    // Param is passed by value, moved
    pub fn set_words(&mut self, v: ::protobuf::RepeatedField<NlWord>) {
        self.words = v;
    }

    // Mutable pointer to the field.
    pub fn mut_words(&mut self) -> &mut ::protobuf::RepeatedField<NlWord> {
        &mut self.words
    }

    // Take field
    pub fn take_words(&mut self) -> ::protobuf::RepeatedField<NlWord> {
        ::std::mem::replace(&mut self.words, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NlSentence {
    fn is_initialized(&self) -> bool {
        for v in &self.words {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.words)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.words {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.words {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlSentence {
        NlSentence::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NlWord>>(
                    "words",
                    |m: &NlSentence| { &m.words },
                    |m: &mut NlSentence| { &mut m.words },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlSentence>(
                    "NlSentence",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlSentence {
        static mut instance: ::protobuf::lazy::Lazy<NlSentence> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlSentence,
        };
        unsafe {
            instance.get(NlSentence::new)
        }
    }
}

impl ::protobuf::Clear for NlSentence {
    fn clear(&mut self) {
        self.words.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlSentence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlSentence {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlSentences {
    // message fields
    pub sentences: ::protobuf::RepeatedField<NlSentence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlSentences {
    fn default() -> &'a NlSentences {
        <NlSentences as ::protobuf::Message>::default_instance()
    }
}

impl NlSentences {
    pub fn new() -> NlSentences {
        ::std::default::Default::default()
    }

    // repeated .nlpserv.NlSentence sentences = 1;


    pub fn get_sentences(&self) -> &[NlSentence] {
        &self.sentences
    }
    pub fn clear_sentences(&mut self) {
        self.sentences.clear();
    }

    // Param is passed by value, moved
    pub fn set_sentences(&mut self, v: ::protobuf::RepeatedField<NlSentence>) {
        self.sentences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sentences(&mut self) -> &mut ::protobuf::RepeatedField<NlSentence> {
        &mut self.sentences
    }

    // Take field
    pub fn take_sentences(&mut self) -> ::protobuf::RepeatedField<NlSentence> {
        ::std::mem::replace(&mut self.sentences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NlSentences {
    fn is_initialized(&self) -> bool {
        for v in &self.sentences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sentences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sentences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sentences {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlSentences {
        NlSentences::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NlSentence>>(
                    "sentences",
                    |m: &NlSentences| { &m.sentences },
                    |m: &mut NlSentences| { &mut m.sentences },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlSentences>(
                    "NlSentences",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlSentences {
        static mut instance: ::protobuf::lazy::Lazy<NlSentences> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlSentences,
        };
        unsafe {
            instance.get(NlSentences::new)
        }
    }
}

impl ::protobuf::Clear for NlSentences {
    fn clear(&mut self) {
        self.sentences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlSentences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlSentences {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlDocumentSimilarity {
    // message fields
    pub documentId: i32,
    pub content: ::std::string::String,
    pub similarity: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlDocumentSimilarity {
    fn default() -> &'a NlDocumentSimilarity {
        <NlDocumentSimilarity as ::protobuf::Message>::default_instance()
    }
}

impl NlDocumentSimilarity {
    pub fn new() -> NlDocumentSimilarity {
        ::std::default::Default::default()
    }

    // int32 documentId = 1;


    pub fn get_documentId(&self) -> i32 {
        self.documentId
    }
    pub fn clear_documentId(&mut self) {
        self.documentId = 0;
    }

    // Param is passed by value, moved
    pub fn set_documentId(&mut self, v: i32) {
        self.documentId = v;
    }

    // string content = 2;


    pub fn get_content(&self) -> &str {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content, ::std::string::String::new())
    }

    // float similarity = 3;


    pub fn get_similarity(&self) -> f32 {
        self.similarity
    }
    pub fn clear_similarity(&mut self) {
        self.similarity = 0.;
    }

    // Param is passed by value, moved
    pub fn set_similarity(&mut self, v: f32) {
        self.similarity = v;
    }
}

impl ::protobuf::Message for NlDocumentSimilarity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.documentId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.similarity = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.documentId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.documentId, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.content);
        }
        if self.similarity != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.documentId != 0 {
            os.write_int32(1, self.documentId)?;
        }
        if !self.content.is_empty() {
            os.write_string(2, &self.content)?;
        }
        if self.similarity != 0. {
            os.write_float(3, self.similarity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlDocumentSimilarity {
        NlDocumentSimilarity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "documentId",
                    |m: &NlDocumentSimilarity| { &m.documentId },
                    |m: &mut NlDocumentSimilarity| { &mut m.documentId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "content",
                    |m: &NlDocumentSimilarity| { &m.content },
                    |m: &mut NlDocumentSimilarity| { &mut m.content },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "similarity",
                    |m: &NlDocumentSimilarity| { &m.similarity },
                    |m: &mut NlDocumentSimilarity| { &mut m.similarity },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlDocumentSimilarity>(
                    "NlDocumentSimilarity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlDocumentSimilarity {
        static mut instance: ::protobuf::lazy::Lazy<NlDocumentSimilarity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlDocumentSimilarity,
        };
        unsafe {
            instance.get(NlDocumentSimilarity::new)
        }
    }
}

impl ::protobuf::Clear for NlDocumentSimilarity {
    fn clear(&mut self) {
        self.documentId = 0;
        self.content.clear();
        self.similarity = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlDocumentSimilarity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlDocumentSimilarity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlDocumentSimilaritySet {
    // message fields
    pub docs: ::protobuf::RepeatedField<NlDocumentSimilarity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlDocumentSimilaritySet {
    fn default() -> &'a NlDocumentSimilaritySet {
        <NlDocumentSimilaritySet as ::protobuf::Message>::default_instance()
    }
}

impl NlDocumentSimilaritySet {
    pub fn new() -> NlDocumentSimilaritySet {
        ::std::default::Default::default()
    }

    // repeated .nlpserv.NlDocumentSimilarity docs = 1;


    pub fn get_docs(&self) -> &[NlDocumentSimilarity] {
        &self.docs
    }
    pub fn clear_docs(&mut self) {
        self.docs.clear();
    }

    // Param is passed by value, moved
    pub fn set_docs(&mut self, v: ::protobuf::RepeatedField<NlDocumentSimilarity>) {
        self.docs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_docs(&mut self) -> &mut ::protobuf::RepeatedField<NlDocumentSimilarity> {
        &mut self.docs
    }

    // Take field
    pub fn take_docs(&mut self) -> ::protobuf::RepeatedField<NlDocumentSimilarity> {
        ::std::mem::replace(&mut self.docs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NlDocumentSimilaritySet {
    fn is_initialized(&self) -> bool {
        for v in &self.docs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.docs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.docs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.docs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlDocumentSimilaritySet {
        NlDocumentSimilaritySet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NlDocumentSimilarity>>(
                    "docs",
                    |m: &NlDocumentSimilaritySet| { &m.docs },
                    |m: &mut NlDocumentSimilaritySet| { &mut m.docs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlDocumentSimilaritySet>(
                    "NlDocumentSimilaritySet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlDocumentSimilaritySet {
        static mut instance: ::protobuf::lazy::Lazy<NlDocumentSimilaritySet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlDocumentSimilaritySet,
        };
        unsafe {
            instance.get(NlDocumentSimilaritySet::new)
        }
    }
}

impl ::protobuf::Clear for NlDocumentSimilaritySet {
    fn clear(&mut self) {
        self.docs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlDocumentSimilaritySet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlDocumentSimilaritySet {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NlDocumentSet {
    // message fields
    pub textList: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NlDocumentSet {
    fn default() -> &'a NlDocumentSet {
        <NlDocumentSet as ::protobuf::Message>::default_instance()
    }
}

impl NlDocumentSet {
    pub fn new() -> NlDocumentSet {
        ::std::default::Default::default()
    }

    // repeated string textList = 1;


    pub fn get_textList(&self) -> &[::std::string::String] {
        &self.textList
    }
    pub fn clear_textList(&mut self) {
        self.textList.clear();
    }

    // Param is passed by value, moved
    pub fn set_textList(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.textList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_textList(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.textList
    }

    // Take field
    pub fn take_textList(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.textList, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NlDocumentSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.textList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.textList {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.textList {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NlDocumentSet {
        NlDocumentSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "textList",
                    |m: &NlDocumentSet| { &m.textList },
                    |m: &mut NlDocumentSet| { &mut m.textList },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NlDocumentSet>(
                    "NlDocumentSet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NlDocumentSet {
        static mut instance: ::protobuf::lazy::Lazy<NlDocumentSet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NlDocumentSet,
        };
        unsafe {
            instance.get(NlDocumentSet::new)
        }
    }
}

impl ::protobuf::Clear for NlDocumentSet {
    fn clear(&mut self) {
        self.textList.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NlDocumentSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NlDocumentSet {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rnlpserv.proto\x12\x07nlpserv\x1a\x12common_types.proto\"\xeb\x02\n\
    \x0eNlCabochaToken\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12'\n\
    \x0fadditional_info\x18\x02\x20\x01(\tR\x0eadditionalInfo\x12!\n\x0cfeat\
    ure_list\x18\x03\x20\x03(\tR\x0bfeatureList\x12\x0e\n\x02ne\x18\x04\x20\
    \x01(\tR\x02ne\x12-\n\x12normalized_surface\x18\x05\x20\x01(\tR\x11norma\
    lizedSurface\x12\x18\n\x07surface\x18\x06\x20\x01(\tR\x07surface\x12\x10\
    \n\x03pos\x18\x07\x20\x01(\tR\x03pos\x12\x12\n\x04pos1\x18\x08\x20\x01(\
    \tR\x04pos1\x12\x12\n\x04pos2\x18\t\x20\x01(\tR\x04pos2\x12\x12\n\x04pos\
    3\x18\n\x20\x01(\tR\x04pos3\x12\x14\n\x05ctype\x18\x0b\x20\x01(\tR\x05ct\
    ype\x12\x14\n\x05cform\x18\x0c\x20\x01(\tR\x05cform\x12\x16\n\x06genkei\
    \x18\r\x20\x01(\tR\x06genkei\x12\x12\n\x04yomi\x18\x0e\x20\x01(\tR\x04yo\
    mi\"\xe0\x02\n\x0eNlCabochaChunk\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\
    \x02id\x12'\n\x0fadditional_info\x18\x02\x20\x01(\tR\x0eadditionalInfo\
    \x12!\n\x0cfeature_list\x18\x03\x20\x03(\tR\x0bfeatureList\x12\x19\n\x08\
    func_pos\x18\x04\x20\x01(\x05R\x07funcPos\x12\x19\n\x08head_pos\x18\x05\
    \x20\x01(\x05R\x07headPos\x12\x12\n\x04link\x18\x06\x20\x01(\x05R\x04lin\
    k\x12\x14\n\x05score\x18\x07\x20\x01(\x02R\x05score\x12\x1b\n\ttoken_pos\
    \x18\x08\x20\x01(\x05R\x08tokenPos\x12\x20\n\x0cnext_link_id\x18\t\x20\
    \x01(\x05R\nnextLinkId\x12\"\n\rprev_link_ids\x18\n\x20\x03(\x05R\x0bpre\
    vLinkIds\x12/\n\x06tokens\x18\x0b\x20\x03(\x0b2\x17.nlpserv.NlCabochaTok\
    enR\x06tokens\"B\n\x0fNlCabochaChunks\x12/\n\x06chunks\x18\x01\x20\x03(\
    \x0b2\x17.nlpserv.NlCabochaChunkR\x06chunks\"\x80\x01\n\x08NlEntity\x12\
    \x16\n\x06entity\x18\x01\x20\x01(\tR\x06entity\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value\x12\x14\n\x05start\x18\x03\x20\x01(\x05R\x05st\
    art\x12\x1e\n\nconfidence\x18\x04\x20\x01(\x02R\nconfidence\x12\x10\n\
    \x03end\x18\x05\x20\x01(\x05R\x03end\";\n\nNlEntities\x12-\n\x08entities\
    \x18\x01\x20\x03(\x0b2\x11.nlpserv.NlEntityR\x08entities\"U\n\x08NlAmoun\
    t\x12)\n\x06entity\x18\x01\x20\x01(\x0b2\x11.nlpserv.NlEntityR\x06entity\
    \x12\x1e\n\nnumericVal\x18\x02\x20\x01(\tR\nnumericVal\"9\n\x0cNlAmountL\
    ist\x12)\n\x06amount\x18\x01\x20\x03(\x0b2\x11.nlpserv.NlAmountR\x06amou\
    nt\"p\n\x12NlTokenizerRequest\x12#\n\x04text\x18\x01\x20\x01(\x0b2\x0f.n\
    lpserv.NlTextR\x04text\x125\n\x07options\x18\x02\x20\x01(\x0b2\x1b.nlpse\
    rv.NlTokenizerOptionsR\x07options\"K\n\x07NlToken\x12\x12\n\x04text\x18\
    \x01\x20\x01(\tR\x04text\x12\x16\n\x06length\x18\x02\x20\x01(\x05R\x06le\
    ngth\x12\x14\n\x05label\x18\x03\x20\x01(\tR\x05label\"4\n\x08NlTokens\
    \x12(\n\x06tokens\x18\x01\x20\x03(\x0b2\x10.nlpserv.NlTokenR\x06tokens\"\
    \x80\x03\n\x12NlTokenizerOptions\x124\n\x15japaneseNameRecognize\x18\x01\
    \x20\x01(\x08R\x15japaneseNameRecognize\x12&\n\x0eplaceRecognize\x18\x02\
    \x20\x01(\x08R\x0eplaceRecognize\x124\n\x15organizationRecognize\x18\x03\
    \x20\x01(\x08R\x15organizationRecognize\x12$\n\rnameRecognize\x18\x04\
    \x20\x01(\x08R\rnameRecognize\x128\n\x17translatedNameRecognize\x18\x05\
    \x20\x01(\x08R\x17translatedNameRecognize\x12<\n\x19numberQuantifierReco\
    gnize\x18\x06\x20\x01(\x08R\x19numberQuantifierRecognize\x128\n\x17allNa\
    medEntityRecognize\x18\x07\x20\x01(\x08R\x17allNamedEntityRecognize\"\
    \x1e\n\x08NlResult\x12\x12\n\x04code\x18\x01\x20\x01(\x05R\x04code\"0\n\
    \x06NlText\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\x12\x12\n\x04la\
    ng\x18\x02\x20\x01(\tR\x04lang\"\xa7\x01\n\x06NlWord\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\x05R\x02id\x12\x14\n\x05lemma\x18\x02\x20\x01(\tR\x05lemma\
    \x12\x18\n\x07postag1\x18\x03\x20\x01(\tR\x07postag1\x12\x18\n\x07postag\
    2\x18\x04\x20\x01(\tR\x07postag2\x12\x17\n\x07head_id\x18\x05\x20\x01(\
    \x05R\x06headId\x12\x16\n\x06deprel\x18\x06\x20\x01(\tR\x06deprel\x12\
    \x12\n\x04name\x18\x07\x20\x01(\tR\x04name\"$\n\x0eNlParseRequest\x12\
    \x12\n\x04text\x18\x01\x20\x01(\tR\x04text\"\xbe\x01\n\x0fNlPinyinReques\
    t\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\x12O\n\x0cpresentation\
    \x18\x02\x20\x01(\x0e2+.nlpserv.NlPinyinRequest.PinyinPresentationR\x0cp\
    resentation\"F\n\x12PinyinPresentation\x12\n\n\x06NUMBER\x10\0\x12\x12\n\
    \x0eWITH_TONE_MARK\x10\x01\x12\x10\n\x0cWITHOUT_TONE\x10\x02\"3\n\nNlSen\
    tence\x12%\n\x05words\x18\x01\x20\x03(\x0b2\x0f.nlpserv.NlWordR\x05words\
    \"@\n\x0bNlSentences\x121\n\tsentences\x18\x01\x20\x03(\x0b2\x13.nlpserv\
    .NlSentenceR\tsentences\"p\n\x14NlDocumentSimilarity\x12\x1e\n\ndocument\
    Id\x18\x01\x20\x01(\x05R\ndocumentId\x12\x18\n\x07content\x18\x02\x20\
    \x01(\tR\x07content\x12\x1e\n\nsimilarity\x18\x03\x20\x01(\x02R\nsimilar\
    ity\"L\n\x17NlDocumentSimilaritySet\x121\n\x04docs\x18\x01\x20\x03(\x0b2\
    \x1d.nlpserv.NlDocumentSimilarityR\x04docs\"+\n\rNlDocumentSet\x12\x1a\n\
    \x08textList\x18\x01\x20\x03(\tR\x08textList2\x86\x04\n\x08NlpProcs\x120\
    \n\x04Ping\x12\x13.common.PingRequest\x1a\x11.common.PingReply\"\0\x12A\
    \n\x0fParseDependency\x12\x17.nlpserv.NlParseRequest\x1a\x13.nlpserv.NlS\
    entence\"\0\x128\n\tGetPinyin\x12\x18.nlpserv.NlPinyinRequest\x1a\x0f.nl\
    pserv.NlText\"\0\x12;\n\x0cAddDocuments\x12\x16.nlpserv.NlDocumentSet\
    \x1a\x11.nlpserv.NlResult\"\0\x12J\n\x13GetNearestDocuments\x12\x0f.nlps\
    erv.NlText\x1a\x20.nlpserv.NlDocumentSimilaritySet\"\0\x12=\n\tTokenizer\
    \x12\x1b.nlpserv.NlTokenizerRequest\x1a\x11.nlpserv.NlTokens\"\0\x12E\n\
    \x0fEntityExtractor\x12\x1b.nlpserv.NlTokenizerRequest\x1a\x13.nlpserv.N\
    lEntities\"\0\x12<\n\x10ParseAmountTerms\x12\x0f.nlpserv.NlText\x1a\x15.\
    nlpserv.NlAmountList\"\02K\n\x0fCabochaNlpProcs\x128\n\tTokenizer\x12\
    \x0f.nlpserv.NlText\x1a\x18.nlpserv.NlCabochaChunks\"\0B*\n\x12com.samle\
    t.nlpservB\x0cNlpServProtoP\x01\xa2\x02\x03NLPb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
